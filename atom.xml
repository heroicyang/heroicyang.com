<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[HeroicYang's Blog]]></title>
  <subtitle><![CDATA[Pseudo fullstack developer.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://heroicyang.com/"/>
  <updated>2015-04-20T08:01:11.000Z</updated>
  <id>http://heroicyang.com/</id>
  
  <author>
    <name><![CDATA[Heroic Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[前端开发者的 Mac 配置手册（一）]]></title>
    <link href="http://heroicyang.com/2015/04/20/fe-dev-setup-1/"/>
    <id>http://heroicyang.com/2015/04/20/fe-dev-setup-1/</id>
    <published>2015-04-20T06:12:33.000Z</published>
    <updated>2015-04-20T08:01:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote class="blockquote-center">工欲善其事，必先利其器。</blockquote>

<p>目前可供开发人员使用的工具越来越多，合理的使用工具有助于提升开发效率，但种类繁多时选择起来却会让人感觉眼花缭乱。所以我准备在接下来的几篇文章中分享一些我的 Mac 开发环境配置，供大家参考。</p>
<a id="more"></a>
<h3 id="XCode">XCode</h3><p>如果是一台全新的 Mac 电脑，那第一件事情就是去安装 XCode 吧。然后在终端中用如下命令安装 <code>Xcode command line tools</code>，按照指引安装即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br></pre></td></tr></table></figure>
<p><em>如果你不做 Obj-C 开发，可以跳过 XCode 的安装，直接去下载 <code>Xcode command line tools</code> 来安装即可。</em></p>
<h3 id="Homebrew">Homebrew</h3><p>Homebrew 是 Mac 上最受欢迎的<a href="https://en.wikipedia.org/wiki/Package_manager" target="_blank" rel="external">包管理工具</a>。</p>
<h4 id="安装">安装</h4><p>在此之前，必须保证 <code>Xcode command line tools</code>。然后在终端中用如下命令按照指引来安装 Homebrew 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>安装完成之后将 Homebrew 的可执行命令添加到环境变量中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<h4 id="简单使用">简单使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brew install &lt;package_name&gt;  <span class="comment"># 安装包</span></span><br><span class="line">$ brew update                  <span class="comment"># 更新包目录</span></span><br><span class="line">$ brew outdated                <span class="comment"># 查看需要更新的包</span></span><br><span class="line">$ brew upgrade &lt;package_name&gt;  <span class="comment"># 更新包</span></span><br><span class="line">$ brew list                    <span class="comment"># 查看已安装的包</span></span><br></pre></td></tr></table></figure>
<h4 id="Cakebrew">Cakebrew</h4><p>如果你不喜欢命令行方式来管理，那么 Cakebrew 是极好的选择。Cakebrew App 提供了可视化的界面来接管一部分 brew 命令，大多数操作都可以直接在界面上点几下来完成。</p>
<p><a href="https://www.cakebrew.com/" target="_blank" rel="external">下载地址</a></p>
<h3 id="iTerm2">iTerm2</h3><p>替换掉 OS X 自带的 Terminal，不是因为自带的很差劲，而是一款强劲的终端程序可以有效的提升效率（即便是少敲点字符也行）。</p>
<p><a href="http://iterm2.com/" target="_blank" rel="external">下载地址</a></p>
<h4 id="Zsh">Zsh</h4><p><a href="http://zsh.sourceforge.net/" target="_blank" rel="external">Zsh</a> 号称终极 Shell，所以愉快的干掉自带的 Bash 吧（自带的又躺了😂）… Zsh 提供了强大的自动补全功能，能自动补全命令、参数、文件名、进程等。</p>
<p>而 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a> 是基于 Zsh 的功能做了一个扩展，提供了方便的插件管理、主题自定义，以及漂亮的自动完成效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</span><br><span class="line">$ <span class="comment"># 安装完成后将当前的环境变量导入 .zshrc 中</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>在 <code>~/.zshrc</code> 中按照个人喜好配置主题（<code>ZSH_THEME</code>），以及各种插件(<code>plugins</code>)。<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="external">主题太多，任君选择</a>。另外，以下是我的插件启用情况。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=<span class="list">(<span class="keyword">git</span> github git-flow git-extras brew osx node npm copydir copyfile cp sublime zsh-syntax-highlighting)</span></span><br></pre></td></tr></table></figure>
<h3 id="Git">Git</h3><p>我们是前卫的前端工程师，不用 Git 怎么好意思和别人打招呼呢。。。😂</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version     <span class="comment"># 如果提示命令不存在，那用 Homebrew 来安装吧</span></span><br><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<p>然后配置一些全局的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure>
<p>如果使用 SSH 方式来拉取/推送代码，请参考<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="external">这里</a>。而 HTTPS 方式如果不想每次都输入你的 Git 用户名和密码的话，请继续按照以下配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper osxkeychain</span><br></pre></td></tr></table></figure>
<h3 id="Node-js">Node.js</h3><p>我们是前卫的前端工程师，没用过 Node.js 肯定也听过 Node.js 吧，否则真的是不好意思和别人打招呼的😂。。。少年，赶紧去<a href="https://nodejs.org/" target="_blank" rel="external">官网</a>下载安装吧~</p>
<h4 id="NPM">NPM</h4><p>Node 的<a href="https://www.npmjs.com/" target="_blank" rel="external">包管理系统</a>。安装好 Node 之后自带，不过在某些 Node 版本中自带的 NPM 版本较低，你需要执行下面命令来升级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm up npm -g        <span class="comment"># 用 NPM 升级 NPM，感觉很酷对吧？</span></span><br></pre></td></tr></table></figure>
<p>另外，推荐安装以下包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm i gulp -g        <span class="comment"># 前端构建工具</span></span><br><span class="line">$ sudo npm i grunt-cli -g   <span class="comment"># 另一个前端构建工具</span></span><br><span class="line">$ sudo npm i bower -g       <span class="comment"># 前端包管理工具（为毛又一个包管理工具？不要在意这些细节）</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Golang_(optional)">Golang (optional)</h3><p>这一小节算是赠送啦，反正你都看到这里了。。。</p>
<p>Golang 是谷歌开发的一门现代编程语言，强类型、并发、高性能、语言特性简洁高效… 恩，另外，Node 社区的 <a href="https://github.com/tj" target="_blank" rel="external">TJ</a> 大神目前已转投此阵营…</p>
<p>安装就不用说了，上<a href="http://golang.org/" target="_blank" rel="external">官网</a>下载即可。如果你没办法越过 GFW，那去<a href="http://www.golangtc.com/download" target="_blank" rel="external">这里</a>下载吧。</p>
<h4 id="配置">配置</h4><p>我一般会为 Go 配置两个 <code>GOPATH</code>，<code>/usr/local/share/go</code> 用于安装第三方包，<code>~/codes/go</code> 用于放置自己项目代码（工作目录）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"export GOROOT=/usr/local/go"</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export GOPATH=/usr/local/share/go:<span class="variable">$HOME</span>/codes/go"</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:/usr/local/share/go/bin"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3><p><a href="https://www.gitbook.com/book/aaaaaashu/mac-dev-setup/details" target="_blank" rel="external">Mac 开发配置手册</a><br><a href="https://github.com/robbyrussell/oh-my-zsh#basic-installation" target="_blank" rel="external">oh-my-zsh Installation</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3><blockquote class="blockquote-center">工欲善其事，必先利其器。</blockquote>

<p>目前可供开发人员使用的工具越来越多，合理的使用工具有助于提升开发效率，但种类繁多时选择起来却会让人感觉眼花缭乱。所以我准备在接下来的几篇文章中分享一些我的 Mac 开发环境配置，供大家参考。</p>]]>
    
    </summary>
    
      <category term="mac" scheme="http://heroicyang.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写可维护的 Gruntfile.js]]></title>
    <link href="http://heroicyang.com/2013/11/24/maintainable-gruntjs/"/>
    <id>http://heroicyang.com/2013/11/24/maintainable-gruntjs/</id>
    <published>2013-11-24T12:19:27.000Z</published>
    <updated>2014-05-01T02:15:55.000Z</updated>
    <content type="html"><![CDATA[<p>使用<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>已经有很长一段时间了，不得不感叹其社区的壮大，各种插件层出不穷。而在这期间我也换过几种方式来组织<code>Gruntfile.js</code>，但都不是很理想，直到前段时间看到<a href="https://npmjs.org/package/load-grunt-tasks" target="_blank" rel="external">load-grunt-tasks</a>这个插件以及<a href="http://www.thomasboyt.com/2013/09/01/maintainable-grunt.html" target="_blank" rel="external">More maintainable Gruntfiles</a>这篇文章后，我就把项目中的<code>Gruntfile.js</code>都按照该文章作者所述的方式重新组织了一遍。</p>
<p>我就暂且把这种方式用自己的文字记录一下并分享给正在使用<code>Grunt</code>的同学们吧，不过本文也不算是对《More maintainable Gruntfiles》的翻译呐，毕竟我E文太差~</p>
<a id="more"></a>
<h3 id="load-grunt-tasks_插件">load-grunt-tasks 插件</h3><p>首先介绍下<code>load-grunt-tasks</code>这个插件。</p>
<p>我们一般都会把所有用到的插件以及插件的配置写到<code>Gruntfile.js</code>里面，对于小项目来说这个文件最终或许不是很大，但是对于大项目、有很多配置或者很多自定义任务的项目来说，最后这个文件都会变得越来越长，维护起来就成了麻烦。比如下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span><span class="params">(grunt)</span> </span>&#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span><br><span class="line">    concat: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        separator: <span class="string">';'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      dist: &#123;</span><br><span class="line">        src: [<span class="string">'src/\*\*/\*.js'</span>],</span><br><span class="line">        dest: <span class="string">'dist/&lt;%= pkg.name %&gt;.js'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    uglify: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        banner: <span class="string">'/\*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; \*/\n'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      dist: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          <span class="string">'dist/&lt;%= pkg.name %&gt;.min.js'</span>: [<span class="string">'&lt;%= concat.dist.dest %&gt;'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    qunit: &#123;</span><br><span class="line">      files: [<span class="string">'test/\*\*/\*.html'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    jshint: &#123;</span><br><span class="line">      files: [<span class="string">'gruntfile.js'</span>, <span class="string">'src/\*\*/\*.js'</span>, <span class="string">'test/\*\*/\*.js'</span>],</span><br><span class="line">      options: &#123;</span><br><span class="line">        globals: &#123;</span><br><span class="line">          jQuery: <span class="literal">true</span>,</span><br><span class="line">          <span class="built_in">console</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="built_in">module</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="built_in">document</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      files: [<span class="string">'&lt;%= jshint.files %&gt;'</span>],</span><br><span class="line">      tasks: [<span class="string">'jshint'</span>, <span class="string">'qunit'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-qunit'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</span><br><span class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat'</span>);</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">'test'</span>, [<span class="string">'jshint'</span>, <span class="string">'qunit'</span>]);</span><br><span class="line">  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'jshint'</span>, <span class="string">'qunit'</span>, <span class="string">'concat'</span>, <span class="string">'uglify'</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个很标准的<code>Gruntfile.js</code>，显然也算是很简短的了，但是看起来也有点累觉不爱。于是<code>load-grunt-tasks</code>出来帮我们解决了一部分问题。</p>
<p>它会自动读取并加载项目<code>packge.json</code>文件中<code>devDependencies</code>配置下以<code>grunt-*</code>开头的依赖库。于是乎我们就可以用一行代码来搞定上面代码中很多行的<code>loadNpmTasks</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'load-grunt-tasks'</span>)(grunt);</span><br><span class="line"><span class="comment">// 就代替了以下全部</span></span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);</span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-qunit'</span>);</span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</span><br><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Gruntfile-js_继续廋身">Gruntfile.js 继续廋身</h3><p><code>load-grunt-tasks</code>插件替<code>Gruntfile.js</code>省去了那些反复书写的方法调用，接下来就是将整个<code>Gruntfile.js</code>变得干净清爽的步骤了。那就是把上面的各种<code>config</code>分离出去，让它们各自代表自己是属于哪个插件，而不是一口气全写在一起。当然，还有各种用<code>registerTask</code>方法定义的自定义任务，也该单独放到相应的文件中。</p>
<h4 id="自定义任务迁移">自定义任务迁移</h4><p>首先，在项目根目录下建一个名为<code>tasks</code>的目录，在这个目录下来编写各种自定义任务。可以一个任务一个 js 文件，也可以多个简单任务在一个 js 文件，看个人喜好吧。然后在<code>Gruntfile.js</code>中用一行代码来载入这些自定义任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.loadTasks(<span class="string">'tasks'</span>);  <span class="comment">// 即刚刚新建目录的名称</span></span><br></pre></td></tr></table></figure>
<h4 id="配置项迁移">配置项迁移</h4><p>然后再在这个目录下新建一个名为<code>options</code>的子目录(tasks/options)，来存放之前说的那些<code>config</code>们。为每一类<code>config</code>建一个 js 文件，并以配置项节点名作为文件名称，比如下面这样：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks</span><br><span class="line">└── options</span><br><span class="line">    └── concat<span class="class">.js</span></span><br><span class="line">    └── uglify<span class="class">.js</span></span><br><span class="line">    └── qunit<span class="class">.js</span></span><br><span class="line">    └── jshint.js</span><br></pre></td></tr></table></figure>
<p>然后在每个文件中导出对应的配置项，拿<code>concat.js</code>来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = exports = &#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    separator: <span class="string">';'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dist: &#123;</span><br><span class="line">    src: [<span class="string">'src/\*\*/\*.js'</span>],</span><br><span class="line">    dest: <span class="string">'dist/&lt;%= pkg.name %&gt;.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后在<code>Gruntfile.js</code>里用<code>require</code>将配置逐个引入即可，也可以封装一个函数来做这件事情。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadConfig</span><span class="params">(configPath)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  glob.sync(<span class="string">'\*'</span>, &#123; cwd: configPath &#125;)</span><br><span class="line">    .forEach(<span class="function"><span class="keyword">function</span><span class="params">(configFile)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> prop = configFile.replace(<span class="regexp">/\.js$/</span>, <span class="string">''</span>);</span><br><span class="line">      config[prop] = <span class="built_in">require</span>(path.join(__dirname, configPath, configFile));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改写<code>Gruntfile.js</code>中<code>initConfig</code>的调用即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">  pkg: grunt.file.readJSON(<span class="string">'package.json'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">_.extend(config, loadConfig(<span class="string">'./tasks/options/'</span>));</span><br><span class="line">grunt.initConfig(config);</span><br></pre></td></tr></table></figure>
<h3 id="写在最后">写在最后</h3><p>于是乎在每个项目中<code>Gruntfile.js</code>几乎一致，而且也几乎不会再变更。<code>Gruntfile.js</code>、自定义任务、任务配置项各司其职，需要变化时只需对相应文件做出调整即可。</p>
<p>就在前些天，又一位 GitHuber 将这个思路封装成了一个库：<a href="https://github.com/firstandthird/load-grunt-config" target="_blank" rel="external">load-grunt-config</a>，感兴趣的同学可以看看。</p>
<p>最终的<code>Gruntfile.js</code>可以查看这个例子：<a href="https://github.com/heroicyang/cnodeclub/blob/master/Gruntfile.js" target="_blank" rel="external">https://github.com/heroicyang/cnodeclub/blob/master/Gruntfile.js</a></p>
<h3 id="参考资料">参考资料</h3><p>load-grunt-tasks: <a href="https://npmjs.org/package/load-grunt-tasks" target="_blank" rel="external">https://npmjs.org/package/load-grunt-tasks</a><br>More maintainable Gruntfiles: <a href="http://www.thomasboyt.com/2013/09/01/maintainable-grunt.html" target="_blank" rel="external">http://www.thomasboyt.com/2013/09/01/maintainable-grunt.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用<a href="http://gruntjs.com/">Grunt</a>已经有很长一段时间了，不得不感叹其社区的壮大，各种插件层出不穷。而在这期间我也换过几种方式来组织<code>Gruntfile.js</code>，但都不是很理想，直到前段时间看到<a href="https://npmjs.org/package/load-grunt-tasks">load-grunt-tasks</a>这个插件以及<a href="http://www.thomasboyt.com/2013/09/01/maintainable-grunt.html">More maintainable Gruntfiles</a>这篇文章后，我就把项目中的<code>Gruntfile.js</code>都按照该文章作者所述的方式重新组织了一遍。</p>
<p>我就暂且把这种方式用自己的文字记录一下并分享给正在使用<code>Grunt</code>的同学们吧，不过本文也不算是对《More maintainable Gruntfiles》的翻译呐，毕竟我E文太差~</p>]]>
    
    </summary>
    
      <category term="grunt" scheme="http://heroicyang.com/tags/grunt/"/>
    
      <category term="gruntjs" scheme="http://heroicyang.com/tags/gruntjs/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript闭包]]></title>
    <link href="http://heroicyang.com/2013/07/27/javascript-closure/"/>
    <id>http://heroicyang.com/2013/07/27/javascript-closure/</id>
    <published>2013-07-27T10:20:35.000Z</published>
    <updated>2014-05-01T01:57:33.000Z</updated>
    <content type="html"><![CDATA[<p>闭包是JavaScript中的重要特性之一，大多数用过JavaScript的程序员也基本上都接触过闭包，不管是否知道或了解闭包这个概念。比如在用jQuery的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="string">'.btn'</span>).onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>闭包，<a href="http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="external">维基百科</a>的解释是：指引用了自由变量的函数。而我个人认为前端大牛<a href="http://weibo.com/haxy" target="_blank" rel="external">johnhax</a>的解释更加容易理解：闭包就是内部函数能访问外部的变量。</p>
<p>所以，要理解闭包，只要理清楚<strong>变量作用域</strong>这个概念就差不多了。我也把对<strong>变量作用域</strong>的一些个人理解记录在了前两篇文章中，故这里就只简单说说一个函数它可以访问哪些作用域中的变量：</p>
<ol>
<li>该函数自己内部声明的变量</li>
<li>global作用域中的全局变量</li>
<li>如果该函数是内部函数，那它还可以访问其外部函数内声明的变量</li>
</ol>
<p>而对于第三点，就是闭包的行为了，用一个简单的例子来说明。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = foo();</span><br><span class="line">test(); <span class="comment">// 1</span></span><br><span class="line">test(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>简单解读下这段代码：</p>
<ol>
<li><code>bar</code>函数是内部函数，即定义在<code>foo</code>函数内部</li>
<li><code>foo</code>函数调用之后会将<code>bar</code>函数的引用作为返回值</li>
<li>全局作用域中有变量引用了<code>bar</code>函数，即<code>bar</code>函数还处于活动状态</li>
</ol>
<p>于是在<code>foo</code>函数已经被调用结束之后，其内部的<code>i</code>变量仍然没被销毁，而且在每次调用<code>bar</code>函数之后，其值是一直在递增的。  </p>
<p>如果用作用域链来解释，那就更加清晰明了了：  </p>
<p>1.代码载入全局执行环境，开始运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalScopeChain = &#123;</span><br><span class="line">  test: <span class="literal">undefined</span>,</span><br><span class="line">  foo: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fooScopeChain = [globalScopeChain];</span><br></pre></td></tr></table></figure>
<p>2.调用<code>foo</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，`foo`函数的作用域链变为：</span></span><br><span class="line">fooScopeChain = [&#123;</span><br><span class="line">  <span class="built_in">arguments</span>: [],</span><br><span class="line">  i: <span class="number">0</span>,</span><br><span class="line">  bar: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  test: <span class="literal">undefined</span>,</span><br><span class="line">  foo: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了`bar`函数，并初始化其作用域链为：</span></span><br><span class="line">barScopeChain = [fooScopeChain];</span><br></pre></td></tr></table></figure>
<p>3.<code>foo</code>函数调用结束，并将<code>test</code>变量指向<code>foo</code>执行返回的<code>bar</code>函数的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时全局作用域链变为：</span></span><br><span class="line">globalScopeChain = [&#123;</span><br><span class="line">  test: [<span class="built_in">Function</span>],</span><br><span class="line">  foo: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>4.第一次调用<code>test</code>，也就是<code>bar</code>函数。<code>bar</code>函数作用域链上有变量<code>i</code>，且值为<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用域上进行变量查找，找到后做增量赋值操作，所以`i = 1`</span></span><br><span class="line">barScopeChain = [&#123;</span><br><span class="line">  <span class="built_in">arguments</span>: []</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  i: <span class="number">0</span>,</span><br><span class="line">  bar: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  test: <span class="literal">undefined</span>,</span><br><span class="line">  foo: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>5.第二次调用<code>test</code>，与第4步相同。只是本次调用时，其作用域链上的<code>i</code>值已经在上一次调用后变成<code>1</code>了，所以增量赋值操作之后，得到结果为<code>2</code>。  </p>
<p>因此，只要理解了作用域链，再来看闭包就很清晰了。不过对于闭包的解释，我仍然推荐开篇所提到的：<strong>内部函数能访问外部的变量</strong>，简单易懂。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>闭包是JavaScript中的重要特性之一，大多数用过JavaScript的程序员也基本上都接触过闭包，不管是否知道或了解闭包这个概念。比如在用jQuery的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="string">'.btn'</span>).onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>闭包，<a href="http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科</a>的解释是：指引用了自由变量的函数。而我个人认为前端大牛<a href="http://weibo.com/haxy">johnhax</a>的解释更加容易理解：闭包就是内部函数能访问外部的变量。</p>
<p>所以，要理解闭包，只要理清楚<strong>变量作用域</strong>这个概念就差不多了。我也把对<strong>变量作用域</strong>的一些个人理解记录在了前两篇文章中，故这里就只简单说说一个函数它可以访问哪些作用域中的变量：</p>
<ol>
<li>该函数自己内部声明的变量</li>
<li>global作用域中的全局变量</li>
<li>如果该函数是内部函数，那它还可以访问其外部函数内声明的变量</li>
</ol>
<p>而对于第三点，就是闭包的行为了，用一个简单的例子来说明。</p>]]>
    
    </summary>
    
      <category term="closure" scheme="http://heroicyang.com/tags/closure/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript变量作用域（续）]]></title>
    <link href="http://heroicyang.com/2013/07/22/javascript-scope-sequel/"/>
    <id>http://heroicyang.com/2013/07/22/javascript-scope-sequel/</id>
    <published>2013-07-22T14:14:06.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>接<a href="http://heroicyang.com/2013/07/14/javascript-variable-scope/" target="_blank" rel="external">上篇</a>，已经大致明确了以下几点：</p>
<ol>
<li>JavaScript没有块级作用域，只有函数(局部)作用域和全局作用域</li>
<li>函数中未使用<code>var</code>关键字声明的变量会成为全局变量</li>
<li>同名时局部变量访问优先级高于全局变量 </li>
<li>JavaScript具有变量声明提前的特性</li>
</ol>
<p>接下来根据上篇留下的最后一段代码，继续谈谈变量作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这段代码最终会在控制台打印出<code>&#39;global&#39;</code>，而并非<code>&#39;foo&#39;</code>。可以看出，函数运行时能访问到的作用域是它被定义时的作用域，不是被调用时的作用域。</p>
<p>每当谈及JavaScript作用域的时候，基本上都会提到“词法作用域”、“执行环境”、“活动对象”、“作用域链”这几个概念，而了解这些概念将有助于理解JavaScript中的闭包。我也谈谈我对此的理解，如误欢迎指正，不胜感激。</p>
<a id="more"></a>
<h3 id="词法作用域">词法作用域</h3><p>词法作用域，也称静态作用域，也即是说函数的作用域是定义时决定的，而非运行时。最开始的代码就阐明了这一点，所以在源码时期就可以通过分析得出一个函数的作用域。JavaScript正是基于词法作用域的语言。</p>
<h3 id="执行环境">执行环境</h3><p>JavaScript需要一个环境来运行，比如客户端的浏览器和服务端的Node.js。而执行环境有分为<strong>全局执行环境</strong>和<strong>局部执行环境</strong>。</p>
<h4 id="全局执行环境">全局执行环境</h4><p>在浏览器中，全局执行环境为<code>window</code>对象。因此当JavaScript代码运行时，所有的全局变量和函数都作为了<code>window</code>对象的属性和方法创建。全局执行环境关联了一个<strong>作用域链</strong>，包含了全局执行环境中的变量对象。</p>
<h4 id="局部执行环境、活动对象">局部执行环境、活动对象</h4><p>每个函数在定义时，都会关联一个初始的<strong>作用域链</strong>，将当前执行环境作用域链上的变量对象附加到这个关联的<strong>作用域链</strong>上。每个函数都是有自己的执行环境的，也就是局部执行环境。当一个函数被调用，进入局部执行环境。随之创建了<strong>活动对象</strong>，包含<code>arguments</code>和局部变量，然后将其附加到作用域链的前端（即下标为0）。在函数执行之后，退出局部执行环境，把控制权交给之前的执行环境（可能是全局执行环境，也有可能是另一个局部执行环境）。</p>
<h3 id="作用域链">作用域链</h3><p>前面已经反复提到了作用域链，也基本解释了作用域链，它差不多等同于一个对象列表或链表。为了更好的理解作用域链，还是结合最开始的那段代码来进行解释，不然有点不是很好理清楚。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><em>1.代码运行开始，在全局执行环境中，全局环境关联了一个作用域链，变量对象包含<code>name</code>、<code>foo</code>、<code>bar</code>。然后<code>foo</code>函数和<code>bar</code>函数也各自关联了自己作用域链。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">globalScopeChain = &#123;</span><br><span class="line">    name: <span class="string">'global'</span>,</span><br><span class="line">    foo: [<span class="built_in">Function</span>],</span><br><span class="line">    bar: [<span class="built_in">Function</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fooScopeChain = [globalScopeChain]</span><br><span class="line">barScopeChain = [globalScopeChain]</span><br></pre></td></tr></table></figure>
<p><em>2.调用<code>foo</code>函数，进入<code>foo</code>函数的局部执行环境，创建活动对象包含<code>arguments</code>、<code>name</code>，并将活动对象添加到作用域链的前端。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fooScopeChain = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: [],</span><br><span class="line">    name: <span class="string">'foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'global'</span>,</span><br><span class="line">    foo: [<span class="built_in">Function</span>],</span><br><span class="line">    bar: [<span class="built_in">Function</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><em>3.调用<code>bar</code>函数，进入<code>bar</code>函数的局部执行环境，创建活动对象包含<code>arguments</code>，然后也将活动对象添加到作用域链的前端。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">barScopeChain = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'global'</span>,</span><br><span class="line">    foo: [<span class="built_in">Function</span>],</span><br><span class="line">    bar: [<span class="built_in">Function</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>而变量的查找，就是在整个作用域链上进行，从第一个对象开始，直到作用域链的顶端（即全局）。这也就是实例代码中打印出<code>&#39;global&#39;</code>的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接<a href="http://heroicyang.com/2013/07/14/javascript-variable-scope/">上篇</a>，已经大致明确了以下几点：</p>
<ol>
<li>JavaScript没有块级作用域，只有函数(局部)作用域和全局作用域</li>
<li>函数中未使用<code>var</code>关键字声明的变量会成为全局变量</li>
<li>同名时局部变量访问优先级高于全局变量 </li>
<li>JavaScript具有变量声明提前的特性</li>
</ol>
<p>接下来根据上篇留下的最后一段代码，继续谈谈变量作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这段代码最终会在控制台打印出<code>&#39;global&#39;</code>，而并非<code>&#39;foo&#39;</code>。可以看出，函数运行时能访问到的作用域是它被定义时的作用域，不是被调用时的作用域。</p>
<p>每当谈及JavaScript作用域的时候，基本上都会提到“词法作用域”、“执行环境”、“活动对象”、“作用域链”这几个概念，而了解这些概念将有助于理解JavaScript中的闭包。我也谈谈我对此的理解，如误欢迎指正，不胜感激。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="scope" scheme="http://heroicyang.com/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript变量作用域]]></title>
    <link href="http://heroicyang.com/2013/07/14/javascript-variable-scope/"/>
    <id>http://heroicyang.com/2013/07/14/javascript-variable-scope/</id>
    <published>2013-07-14T14:11:36.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>所谓作用域，也就是变量和函数起作用的区域，不同的语言有着不同的实现。而在JavaScript中，这也是往往让人迷糊的地方，也是JavaScript中必须理解的特性之一。  </p>
<p>首先来看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 'bar'</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>从运行结果不难看出，变量<code>i</code>在循环体结束之后仍然可以访问。而诸如Java、C#等语言中，循环结束之后便不能再访问到循环体中的变量了。继续看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'heroic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'heroic'</span></span><br></pre></td></tr></table></figure>
<p><strong>结合两段代码可以知道，在JavaScript中是不存在块级作用域的，只存在函数作用域（也称“本地作用域”）和全局作用域。</strong>而作用域中的变量我们分别称其为：局部变量和全局变量。  </p>
<p>前辈们（前端的长辈们，嚯嚯）常常反复在说，全局变量是魔鬼啊，魔鬼啊。。。（回声）那到底是嘛原因呢？咱接着往下说。</p>
<a id="more"></a>
<ul>
<li>JavaScript中如果不使用<code>var</code>关键字来声明变量，则该变量会成为全局变量。  </li>
<li>在整个作用域中，都可以访问并修改这些全局变量，不可控，BUG随之而来。  </li>
<li>局部变量的访问优先级高于全局变量，所以在某种特殊情况下（JavaScript变量声明提前特性），可能得不到我们想要的结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  name = <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 'foo'</span></span><br><span class="line">  name = <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'bar'</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子很好理解，由于在<code>foo</code>中没有使用<code>var</code>关键字来声明<code>name</code>变量，所以可以在整个全局作用域中访问并修改该变量的值，在实际项目中必然会混乱不堪，引入不可控的BUG等等。接下来看看这个可能对于初学者来说有点迷糊的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'heroic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>
<p>这就是前面提到的<strong>声明提前</strong>，JavaScript中变量和函数以及函数的参数的申明都是在一个类似于预编译的时期就做了，而在运行时期才是创建变量赋值表达式和函数表达式等。所以上面的代码等同于：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">name</span> = <span class="string">'heroic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> foo() &#123;</span><br><span class="line">  var <span class="keyword">name</span>;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">name</span>);</span><br><span class="line">  <span class="keyword">name</span> = <span class="string">'foo'</span>;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>所谓作用域，也就是变量和函数起作用的区域，不同的语言有着不同的实现。而在JavaScript中，这也是往往让人迷糊的地方，也是JavaScript中必须理解的特性之一。  </p>
<p>首先来看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 'bar'</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>从运行结果不难看出，变量<code>i</code>在循环体结束之后仍然可以访问。而诸如Java、C#等语言中，循环结束之后便不能再访问到循环体中的变量了。继续看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'heroic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'foo'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'heroic'</span></span><br></pre></td></tr></table></figure>
<p><strong>结合两段代码可以知道，在JavaScript中是不存在块级作用域的，只存在函数作用域（也称“本地作用域”）和全局作用域。</strong>而作用域中的变量我们分别称其为：局部变量和全局变量。  </p>
<p>前辈们（前端的长辈们，嚯嚯）常常反复在说，全局变量是魔鬼啊，魔鬼啊。。。（回声）那到底是嘛原因呢？咱接着往下说。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于《JavaScript Web Application》中的bind方法]]></title>
    <link href="http://heroicyang.com/2013/06/24/bind-function-in-javascript-web-application-book/"/>
    <id>http://heroicyang.com/2013/06/24/bind-function-in-javascript-web-application-book/</id>
    <published>2013-06-24T13:04:39.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>去年底就草草了了的翻过<a href="http://book.douban.com/subject/10733304/" target="_blank">《JavaScript Web Application》</a>这本书，当时就遇到好几个地方没怎么看明白，当时也没有去深究，就只是简单的过一遍这本书。由于此前JavaScript方面的知识匮乏，所以把这本书就缓在阅读队列里了，最近才轮到。其间读了好几本基础和进阶的书，所以这次读这本书，很多之前不明白的地方就豁然明了了。不过好记性不如烂笔头，没准下次忘记了呢。  </p>
<p>记得此前书中对ES5 <code>bind()</code>方法的实现就是一个让我感到迷糊的地方（中文版P16）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = [].slice</span><br><span class="line">      , args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      , self = <span class="keyword">this</span></span><br><span class="line">      , nop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;  <span class="comment">// ① `nop`（函数）的作用？</span></span><br><span class="line">      , bound = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// ② 为什么要做`instanceof`判断？</span></span><br><span class="line">          <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> nop ? <span class="keyword">this</span> : (context || &#123;&#125;),</span><br><span class="line">                              args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 为什么要设置它俩的原型？</span></span><br><span class="line">    nop.prototype = self.prototype;</span><br><span class="line">    bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>bind()</code>：用来动态改变函数调用时其内部<code>this</code>对象的引用，使目标函数基于正确的上下文进行调用。jQuery中实现为<code>$.proxy()</code>方法，ES5则自带了。</p>
</blockquote>
<p>上面代码中① ② ③都是我此前不明白的地方，不过在这次阅读的过程中，就豁然开朗了。</p>
<a id="more"></a>
<p>让我来实现这个方法的话，或许应该是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取名为`bind1`好了，方便后面对比</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> slice = [].slice</span><br><span class="line">    , args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    , self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(context || &#123;&#125;, args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是不会引入<code>nop</code>这个空函数，不会做<code>intanceof</code>判断，不会有原型设置。当然，这个实现是没有啥大问题的，不就是改变函数调用时的上下文环境么，貌似妥妥的呢。  </p>
<p>但是现在仔细想想，这个实现是没错，但不完善。因为JavaScript中一个函数除了可以做普通的函数调用以外，还充当了构造函数的作用，所以就可能会有下面这样的代码。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'test'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].slice.call(<span class="built_in">arguments</span>), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = func.bind(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  , fun1 = func.bind1(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">fun(<span class="number">4</span>);  <span class="comment">// [ 1, 2, 3, 4 ] &#123; name: 'test' &#125;</span></span><br><span class="line"><span class="keyword">var</span> newFun = <span class="keyword">new</span> fun(<span class="number">4</span>);  <span class="comment">// [ 1, 2, 3, 4 ] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">fun1(<span class="number">4</span>);  <span class="comment">// [ 1, 2, 3, 4 ] &#123; name: 'test' &#125;</span></span><br><span class="line"><span class="keyword">var</span> newFun1 = <span class="keyword">new</span> fun1(<span class="number">4</span>);  <span class="comment">// [ 1, 2, 3, 4 ] &#123; name: 'test' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newFun <span class="keyword">instanceof</span> fun);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newFun <span class="keyword">instanceof</span> func);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newFun1 <span class="keyword">instanceof</span> fun1);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newFun1 <span class="keyword">instanceof</span> func);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如此可见，在实现<code>bind()</code>方法的时候，除了考虑一般的函数调用以外，还得考虑其结合<code>new</code>关键字使用时的构造函数的特性。因此以我在第一次看这本书时的认知，看不明白也就不奇怪了，嚯嚯。。  </p>
<p>那就来继续解最开始的那三个圈住的迷惑：</p>
<ul>
<li>① <code>var nop = function () {}</code> ：这并是一个普通的函数，而是一个构造函数，把它用作返回的<code>bound</code>函数的原型，以便于代码中做<code>instanceof</code>判断。</li>
<li>② 鉴于前面的解释，这里做<code>instanceof</code>判断就无可厚非了。</li>
<li>③ 先设置临时构造函数的原型为调用<code>bind()</code>方法时的上下文对象的原型，即目标函数的原型。然后将临时构造函数的一个实例设置为<code>bound</code>函数的原型，原型就链起来了。这样，在对bind后的函数进行<code>new</code>关键字操作的时候，就可以获得原目标函数的特性了。</li>
</ul>
<blockquote>
<p>关于继承和原型，可以参见我的前几篇<a href="http://heroicyang.com/2013/06/07/javascript-class-inherit-optimized/" target="_blank" rel="external">文章</a>。</p>
</blockquote>
<p>最后，再补一个例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; name: <span class="string">'test'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PersonA = Person.bind(obj, <span class="string">'heroic'</span>)</span><br><span class="line">  , PersonB = Person.bind1(obj, <span class="string">'heroic'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> PersonA()</span><br><span class="line">  , p2 = <span class="keyword">new</span> PersonB();</span><br><span class="line"></span><br><span class="line">p1.printName();  <span class="comment">// 'heroic'</span></span><br><span class="line">p2.printName();  <span class="comment">// TypeError: Object [object Object] has no method 'printName'</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>去年底就草草了了的翻过<a href="http://book.douban.com/subject/10733304/" target="_blank">《JavaScript Web Application》</a>这本书，当时就遇到好几个地方没怎么看明白，当时也没有去深究，就只是简单的过一遍这本书。由于此前JavaScript方面的知识匮乏，所以把这本书就缓在阅读队列里了，最近才轮到。其间读了好几本基础和进阶的书，所以这次读这本书，很多之前不明白的地方就豁然明了了。不过好记性不如烂笔头，没准下次忘记了呢。  </p>
<p>记得此前书中对ES5 <code>bind()</code>方法的实现就是一个让我感到迷糊的地方（中文版P16）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = [].slice</span><br><span class="line">      , args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      , self = <span class="keyword">this</span></span><br><span class="line">      , nop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;  <span class="comment">// ① `nop`（函数）的作用？</span></span><br><span class="line">      , bound = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// ② 为什么要做`instanceof`判断？</span></span><br><span class="line">          <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> nop ? <span class="keyword">this</span> : (context || &#123;&#125;),</span><br><span class="line">                              args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 为什么要设置它俩的原型？</span></span><br><span class="line">    nop.prototype = self.prototype;</span><br><span class="line">    bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>bind()</code>：用来动态改变函数调用时其内部<code>this</code>对象的引用，使目标函数基于正确的上下文进行调用。jQuery中实现为<code>$.proxy()</code>方法，ES5则自带了。</p>
</blockquote>
<p>上面代码中① ② ③都是我此前不明白的地方，不过在这次阅读的过程中，就豁然开朗了。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb中随机的查询文档记录]]></title>
    <link href="http://heroicyang.com/2013/06/20/random-record-in-mongodb/"/>
    <id>http://heroicyang.com/2013/06/20/random-record-in-mongodb/</id>
    <published>2013-06-20T13:59:46.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>在实际应用场景中，几乎都会有随机获取数据记录的需求。而这个需求在Mongodb却不是很好实现，就目前而言，大致上有三种解决方案：</p>
<ol>
<li>先计算出一个从<code>0</code>到记录总数之间的随机数，然后采用<code>skip(yourRandomNumber)</code>方法。</li>
<li>为每一条记录增设<code>random</code>字段，插入数据时赋值为<code>Math.random()</code>，查询时采用<code>$gte</code>和<code>$lte</code>。</li>
<li>借助Mongodb对地理空间索引（<code>geospatial indexes</code>）的支持，从而可以在第二种方法的基础上来实现随机记录的获取。</li>
</ol>
<p>因为Mongodb是不建议使用<code>skip</code>方法的，所以这里就略去第一种方法吧。</p>
<h3 id="方法二">方法二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: <span class="built_in">Math</span>.random(), content: <span class="string">'balabala0...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: <span class="built_in">Math</span>.random(), content: <span class="string">'balabala1...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: <span class="built_in">Math</span>.random(), content: <span class="string">'balabala2...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: <span class="built_in">Math</span>.random(), content: <span class="string">'balabala3...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: <span class="built_in">Math</span>.random(), content: <span class="string">'balabala4...'</span> &#125;)</span><br><span class="line"><span class="comment">/* more records... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* create index */</span></span><br><span class="line">&gt; db.twitter.ensureIndex(&#123; username: <span class="number">1</span>, random: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line">&gt; rand = <span class="built_in">Math</span>.random()</span><br><span class="line">&gt; result = db.twitter.findOne(&#123; username: <span class="string">'heroic'</span>, random: &#123; $gte: rand &#125; &#125;)</span><br><span class="line">&gt; <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;   result = db.twitter.findOne(&#123; username: <span class="string">'heroic'</span>, random: &#123; $lte: rand &#125; &#125;)</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三">方法三</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: [<span class="built_in">Math</span>.random(), <span class="number">0</span>], content: <span class="string">'balabala0...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: [<span class="built_in">Math</span>.random(), <span class="number">0</span>], content: <span class="string">'balabala1...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: [<span class="built_in">Math</span>.random(), <span class="number">0</span>], content: <span class="string">'balabala2...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: [<span class="built_in">Math</span>.random(), <span class="number">0</span>], content: <span class="string">'balabala3...'</span> &#125;)</span><br><span class="line">&gt; db.twitter.save(&#123; username: <span class="string">'heroic'</span>, random: [<span class="built_in">Math</span>.random(), <span class="number">0</span>], content: <span class="string">'balabala4...'</span> &#125;)</span><br><span class="line"><span class="comment">/* more records... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* create index */</span></span><br><span class="line">&gt; db.twitter.ensureIndex(&#123; username: <span class="number">1</span>, random: <span class="string">'2d'</span> &#125;)</span><br><span class="line"></span><br><span class="line">&gt; result = db.twitter.findOne(&#123; username: <span class="string">'heroic'</span>, random: &#123; $near: [<span class="built_in">Math</span>.random(), <span class="number">0</span>] &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>更多关于Mongodb地理空间索引资料，请参见<a href="http://docs.mongodb.org/manual/core/2d/" target="_blank" rel="external">这里</a>。</p>
<p>目前这几种方案似乎都不是很理想，但是也没有其他办法了，所以广大程序员们就相约到Mongodb的官方jira提了相应的需求，但是目前仍然没有任何的响应。可以参见<a href="https://jira.mongodb.org/browse/SERVER-533" target="_blank" rel="external">这里</a>，围观一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在实际应用场景中，几乎都会有随机获取数据记录的需求。而这个需求在Mongodb却不是很好实现，就目前而言，大致上有三种解决方案：</p>
<ol>
<li>先计算出一个从<code>0</code>到记录总数之间的随机数，然后采用<code>skip(yourRandomN]]>
    </summary>
    
      <category term="mongodb" scheme="http://heroicyang.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于JavaScript中的继承（三）：再谈类式继承]]></title>
    <link href="http://heroicyang.com/2013/06/07/javascript-class-inherit-optimized/"/>
    <id>http://heroicyang.com/2013/06/07/javascript-class-inherit-optimized/</id>
    <published>2013-06-07T14:23:30.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/2013/05/30/learn-javascript-inherit-class/">《关于JavaScript中的继承（一）：类式继承》</a>中已经基本上实现了类式继承，但仍然还存在一些问题，接下来对之前的实现进一步进行完善。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = parent;</span><br><span class="line">Child.prototype.setChildAge = <span class="function"><span class="keyword">function</span> <span class="params">(age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent.setChildAge(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(parent.age);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>正如代码所见，在为子对象原型添加自己独有方法的时候，父对象也受到了影响，这可不是期望的结果。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// 'child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> child.name;</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// 'heroic'</span></span><br></pre></td></tr></table></figure>
<p>同样如代码所示，<code>child</code>对象持有了两个<code>name</code>属性，一个是通过构造函数拷贝的，另一个是原型链上的，当删除掉本身的<code>name</code>属性后，便访问到了原型链上的了。对于这个问题，解决方案很简单直接：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">Child.prototype = Parent.prototype;  <span class="comment">// 只继承父对象原型链上的属性</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">delete</span> child.name;</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是这种方法也并没有解决最开始的那个问题，即添加或删除子对象原型上的属性时，会一并反映到父对象中。这个时候就需要用到<a href="/2013/06/02/learn-javascript-inherit-proto/">《关于JavaScript中的继承（二）：原型式继承》</a>中用到的临时构造函数了。  </p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将 `Child.prototype = Parent.prototype` 调整为</span></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加`Child`自己的方法之后</span></span><br><span class="line">Child.prototype.setChildAge = <span class="function"><span class="keyword">function</span> <span class="params">(age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent.setChildAge(<span class="number">10</span>);  <span class="comment">// TypeError: Object [object Object] has no method 'setChildAge'</span></span><br></pre></td></tr></table></figure>
<p>不再影响父对象的行为了，而且还可以为<code>inherit</code>方法增加子对象访问父对象行为的特性。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F;</span><br><span class="line">  subClass.prototype._super = superClass.prototype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后重写了子对象的`print()`方法，但依然还是想重用父对象的</span></span><br><span class="line">Child.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before print...balabala...'</span>);</span><br><span class="line">  <span class="keyword">this</span>._super.print.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</span><br><span class="line">child.print();  <span class="comment">// 'before print...balabala...'</span></span><br><span class="line">                <span class="comment">// 'name:  child'</span></span><br></pre></td></tr></table></figure>
<p>最后，如果说这个类式继承模式还有哪点不够完美的话，那就是在子对象继承父对象之后，子对象的构造函数指向被改写了。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.constructor === Parent);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>没办法，只有在继承的最后，把<code>constructor</code>修正回来就是。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">    F.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = <span class="keyword">new</span> F;</span><br><span class="line">    subClass.prototype._super = superClass.prototype;</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">console</span>.log(child.constructor === Child);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.constructor === Parent);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>同时，也如<a href="/2013/06/02/learn-javascript-inherit-proto/">《关于JavaScript中的继承（二）：原型式继承》</a>中提到的那样，利用闭包来减少每次调用<code>inherit()</code>都会生成一个临时构造函数的开销。  </p>
<p>写在最后，类式继承为我们带来了JavaScript中不存在的完整的类的概念，这对于从面向对象语言转过来的程序员来说，可能是很好的方式。但是它也有可能让我们忽略了JavaScript真正的原型式继承。不过这些模式都没有好与坏之分，应该在适合的场景使用合适的方法才是。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="/2013/05/30/learn-javascript-inherit-class/">《关于JavaScript中的继承（一）：类式继承》</a>中已经基本上实现了类式继承，但仍然还存在一些问题，接下来对之前的实现进一步进行完善。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = parent;</span><br><span class="line">Child.prototype.setChildAge = <span class="function"><span class="keyword">function</span> <span class="params">(age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent.setChildAge(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(parent.age);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>正如代码所见，在为子对象原型添加自己独有方法的时候，父对象也受到了影响，这可不是期望的结果。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// 'child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> child.name;</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// 'heroic'</span></span><br></pre></td></tr></table></figure>
<p>同样如代码所示，<code>child</code>对象持有了两个<code>name</code>属性，一个是通过构造函数拷贝的，另一个是原型链上的，当删除掉本身的<code>name</code>属性后，便访问到了原型链上的了。对于这个问题，解决方案很简单直接：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">Child.prototype = Parent.prototype;  <span class="comment">// 只继承父对象原型链上的属性</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">delete</span> child.name;</span><br><span class="line"><span class="built_in">console</span>.log(child.name);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是这种方法也并没有解决最开始的那个问题，即添加或删除子对象原型上的属性时，会一并反映到父对象中。这个时候就需要用到<a href="/2013/06/02/learn-javascript-inherit-proto/">《关于JavaScript中的继承（二）：原型式继承》</a>中用到的临时构造函数了。  </p>]]>
    
    </summary>
    
      <category term="inherit" scheme="http://heroicyang.com/tags/inherit/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于JavaScript中的继承（二）：原型式继承]]></title>
    <link href="http://heroicyang.com/2013/06/02/learn-javascript-inherit-proto/"/>
    <id>http://heroicyang.com/2013/06/02/learn-javascript-inherit-proto/</id>
    <published>2013-06-02T14:52:19.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript中本没有类，所以凡事也不要强求，强扭的瓜总是不填的嘛。继承也无非就是一个对象拥有另外一个对象的特性，所以完全不需要复杂的去模拟面向对象中的类式继承，而借助JavaScript独特的原型机制就可以实现了。同样，需要创建一个对象时也不再采用模拟<strong>类-对象</strong>的方式，而是直接使用JavaScript的对象字面量就好了。因为对于对象来说我们关系的无非也就是它具备哪些属性、有哪些行为而已。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name || <span class="string">'parent'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = &#123;&#125;;  <span class="comment">// 暂时这样</span></span><br><span class="line">child.name = <span class="string">'child'</span>;  <span class="comment">// 在很多情况下我们并不希望继承原对象自己的属性，而是在我们需要时，直接添加就好</span></span><br><span class="line">child.printName();  <span class="comment">// 重点的是我们希望child具备打印自己名字的行为</span></span><br></pre></td></tr></table></figure>
<p>上面的代码目前还不能工作，<a href="http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/" target="_blank" rel="external">上一篇文章</a>中谈到过JavaScript中对象属性查找机制，如果<code>child</code>对象本身没有<code>printName()</code>这个方法，那我们保证其原型上有这个方法，它就能正常工作了。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* var parent... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变child对象的创建方式，不直接采用字面量了，而是用`object`方法来创建</span></span><br><span class="line"><span class="keyword">var</span> child = object(parent);</span><br><span class="line">child.name = <span class="string">'child'</span>;</span><br><span class="line">child.printName();  <span class="comment">// 'child'</span></span><br></pre></td></tr></table></figure>
<p>通过一个<code>object()</code>函数，我们就完全可以实现一个对象从另一个对象继承了。其原理很简单，即在<code>object()</code>函数内部创建一个临时的构造函数，然后修改这个构造函数的原型，最后再返回这个构造函数的一个实例。</p>
<a id="more"></a>
<p>当然，<code>parent</code>对象也并不一定要使用对象字面量，你可以选择任何你能想到的创建对象的方式，如构造函数等。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = object(parent);</span><br><span class="line">child.printName();  <span class="comment">// 'parent'</span></span><br></pre></td></tr></table></figure>
<p>正如前面所述，我们可能并不想继承原对象自己的属性，如上面的例子我们也并不希望它打印出<code>parent</code>。  </p>
<p>原型式继承的规则就是：对象从对象继承，不管父对象是如何而来。而<code>Parent.prototype</code>也是一个对象，所以  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = object(Parent.prototype);</span><br><span class="line">child.printName();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>改写之后，打印<code>child</code>自己的名字时得到的是<code>undefined</code>，因为创建<code>child</code>对象后，还没有给它赋予任何的属性，所以这恰是我们想要的结果。  </p>
<p>而在<code>ECMAScript 5</code>中，原型式继承已经成为了语言特性，为我们增加了<code>Object.create()</code>方法，也就是说可以不用自己实现上面的<code>object</code>方法了。而且<code>Object.create()</code>方法更加强劲、适用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  name: <span class="string">'parent'</span>,</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数接收一个对象，而该对象的属性将作为`child`对象的属性</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  name: &#123; value: <span class="string">'child'</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.printName();  <span class="comment">// 'child'</span></span><br></pre></td></tr></table></figure>
<p>最后，再谈谈最开始实现的<code>object()</code>方法吧，其实还可以做一点点简单的优化。那就是每次调用<code>object()</code>方法时都要创建一个临时的代理构造函数<code>F</code>，而事实上仅需要创建一次就足够了。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F;  </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>我们把代理构造函数放到一个立即执行的函数中创建，然后这个函数返回一个新的、真正实现继承逻辑的函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript中本没有类，所以凡事也不要强求，强扭的瓜总是不填的嘛。继承也无非就是一个对象拥有另外一个对象的特性，所以完全不需要复杂的去模拟面向对象中的类式继承，而借助JavaScript独特的原型机制就可以实现了。同样，需要创建一个对象时也不再采用模拟<strong>类-对象</strong>的方式，而是直接使用JavaScript的对象字面量就好了。因为对于对象来说我们关系的无非也就是它具备哪些属性、有哪些行为而已。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name || <span class="string">'parent'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = &#123;&#125;;  <span class="comment">// 暂时这样</span></span><br><span class="line">child.name = <span class="string">'child'</span>;  <span class="comment">// 在很多情况下我们并不希望继承原对象自己的属性，而是在我们需要时，直接添加就好</span></span><br><span class="line">child.printName();  <span class="comment">// 重点的是我们希望child具备打印自己名字的行为</span></span><br></pre></td></tr></table></figure>
<p>上面的代码目前还不能工作，<a href="http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/">上一篇文章</a>中谈到过JavaScript中对象属性查找机制，如果<code>child</code>对象本身没有<code>printName()</code>这个方法，那我们保证其原型上有这个方法，它就能正常工作了。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* var parent... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变child对象的创建方式，不直接采用字面量了，而是用`object`方法来创建</span></span><br><span class="line"><span class="keyword">var</span> child = object(parent);</span><br><span class="line">child.name = <span class="string">'child'</span>;</span><br><span class="line">child.printName();  <span class="comment">// 'child'</span></span><br></pre></td></tr></table></figure>
<p>通过一个<code>object()</code>函数，我们就完全可以实现一个对象从另一个对象继承了。其原理很简单，即在<code>object()</code>函数内部创建一个临时的构造函数，然后修改这个构造函数的原型，最后再返回这个构造函数的一个实例。</p>]]>
    
    </summary>
    
      <category term="inherit" scheme="http://heroicyang.com/tags/inherit/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于JavaScript中的继承（一）：类式继承]]></title>
    <link href="http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/"/>
    <id>http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/</id>
    <published>2013-05-30T14:19:21.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>“继承”是面向对象中的一个概念，说开去无非就是代码重用的一种方式罢了。  </p>
<p>虽然JavaScript并不是一门真正的面向对象语言，甚至连类的概念都没有。但得益于构造器的存在，在JavaScript中是可以完全模拟出 <strong>类-对象</strong> 行为的。如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>看上去除了变量声明时不是强类型之外，完全与面向对象如出一辙。所以谈及继承时，大家首推的也是一种叫“类式继承”的手法了。  </p>
<h3 id="类式继承之基于原型链">类式继承之基于原型链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Child.inherit(Parent);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面的伪代码是类式继承的理想状态，但<code>inherit</code>方法并不存在，需要由自己实现。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> superClass();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了实现 Child.inherit(Parent) 这样的效果</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.inherit = <span class="function"><span class="keyword">function</span> <span class="params">(superClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototype = <span class="keyword">new</span> superClass();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和计划中的一样，子对象不仅继承了父对象的属性，也继承了父对象原型上的方法。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.name = <span class="string">'test'</span>;</span><br><span class="line">child.printName();  <span class="comment">// 'test'</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式却存在一些问题：</p>
<ol>
<li>对象属性的写操作是直接发生的，即对象如果不存在这个属性，则为该对象创建这个属性，并为其赋值；如果存在，则直接为其赋新值。而对于对象属性的读操作，则完全不一样了：首先查找对象本身是否有该属性，有则返回，没有则查找其原型链，直到找到该属性为止，如果到了原型链的最顶层(Object)都没找到，则返回<code>undefined</code>。由于存在这种读写的不对等性，我们都不会采取从父对象继承属性，而是直接为子对象添加属性即可，而需要继承的方法则放到原型上。</li>
<li>且上面的实现中，我们无法完成这样的初始化：<code>var child = new Child(&#39;test&#39;)</code>  </li>
</ol>
<p>利用原型链实现的类式继承先放一边，为了解决在初始化就能传入参数的问题，便产生了一种叫“借用构造函数”方式的继承。  </p>
<h3 id="类式继承之借用构造函数">类式继承之借用构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">  <span class="keyword">this</span>.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="comment">// 或者在多参数的情况下</span></span><br><span class="line">  <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'test'</span>);</span><br><span class="line">child.printName();  <span class="comment">// 'test'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line">parent.printName();  <span class="comment">// 'heroic'</span></span><br></pre></td></tr></table></figure>
<p>首先来谈谈这种机制相对于第一种的优点，Talk is cheap, Show me the code.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tags = [<span class="string">'.NETer'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ChildA = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">ChildA.prototype = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ChildB = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child_a = <span class="keyword">new</span> ChildA();</span><br><span class="line">child_a.tags.push(<span class="string">'Javaer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child_b = <span class="keyword">new</span> ChildB();</span><br><span class="line">child_b.tags.push(<span class="string">'Pythoner'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child_a.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Javaer</span></span><br><span class="line"><span class="built_in">console</span>.log(child_b.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Pythoner</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parent.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Javaer</span></span><br><span class="line"><span class="comment">// WTF...Why is my tags contains `Javaer` ?</span></span><br></pre></td></tr></table></figure>
<p>显而易见，借用构造函数方式在继承时是采取一份单独的拷贝，而原型链方式则是指向同一个引用。（但是由此可见，原型链上的属性或方法不会在每个实例中都创建一次。）  </p>
<p>接下来则是谈谈缺陷了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">Parent.prototype.papapa = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'pa pa pa...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.papapa();  <span class="comment">// TypeError: Object [object Object] has no method 'papapa'</span></span><br><span class="line"><span class="comment">// Yeah, you're too young, so...</span></span><br></pre></td></tr></table></figure>
<p>借用构造函数其实是在构造时，通过改写方法调用上下文来实现属性的拷贝，所以并未涉及到<code>prototype</code>，所以就没有办法继承原型了。  </p>
<p>由于原型链上的属性或方法不会在每个实例中都创建一次，所以是我们放置需要重用的属性和方法的理想地方；而借用构造函数则可以使子对象拥有自己一份独立的拷贝，不存在意外改写父对象属性的风险。所以两者互补产生了第三种比较完美的继承方式。  </p>
<h3 id="类式继承之组合模式">类式继承之组合模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">  <span class="keyword">this</span>.tags = [<span class="string">'coder'</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span>, <span class="keyword">this</span>.name, <span class="string">', tags: '</span>, <span class="keyword">this</span>.tags.join(<span class="string">', '</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'test'</span>);</span><br><span class="line">child.tags.push(<span class="string">'player'</span>);</span><br><span class="line"></span><br><span class="line">child.print();  <span class="comment">// name:  test , tags:  coder, player</span></span><br><span class="line">parent.print();  <span class="comment">// name:  heroic , tags:  coder</span></span><br></pre></td></tr></table></figure>
<p>近乎完美的实现，子对象继承了父对象的成员，但拥有自己的一份拷贝，不会担心修改自己而影响到父对象；子对象也复用了父对象原型中的方法；且子对象也可以传递任意参数给父对象的构造函数。可谓是面向对象中“类式继承”的准确诠释。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>“继承”是面向对象中的一个概念，说开去无非就是代码重用的一种方式罢了。  </p>
<p>虽然JavaScript并不是一门真正的面向对象语言，甚至连类的概念都没有。但得益于构造器的存在，在JavaScript中是可以完全模拟出 <strong>类-对象</strong> 行为的。如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>看上去除了变量声明时不是强类型之外，完全与面向对象如出一辙。所以谈及继承时，大家首推的也是一种叫“类式继承”的手法了。  </p>
<h3 id="类式继承之基于原型链">类式继承之基于原型链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Child.inherit(Parent);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="inherit" scheme="http://heroicyang.com/tags/inherit/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[折腾了个新主题]]></title>
    <link href="http://heroicyang.com/2013/05/22/hexo-theme-modernist/"/>
    <id>http://heroicyang.com/2013/05/22/hexo-theme-modernist/</id>
    <published>2013-05-22T15:36:51.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>前几天偶然发现了一个Github Page主题：<a href="http://orderedlist.github.io/modernist/" target="_blank" rel="external">Modernist</a>，觉着很舒服。作者将其开源在Github上的，所以我就fork下来自己折腾了个<a href="https://github.com/tommy351/hexo" target="_blank" rel="external">Hexo</a>的主题。  </p>
<p>根据<a href="https://github.com/tommy351/hexo-theme-light" target="_blank" rel="external">light</a>主题的结构修改而来，但是去掉了侧边栏，改成一栏，所以随之也就没有了light主题的那些widget了。不过我增加了国内的<a href="http://duoshuo.com/" target="_blank" rel="external">多说评论框</a>的配置，以及更好的响应式支持。  </p>
<p>主题已经放到<a href="https://github.com/heroicyang/hexo-theme-modernist" target="_blank" rel="external">Github</a>上了，也已完全适用于最新版的Hexo。<span class="text-lt">为了更好的使用这个主题，建议clone我fork的<a href="https://github.com/heroicyang/hexo" target="_blank" rel="external">hexo</a>项目到本地，使用<code>/path/to/hexo/bin/hexo</code>来代替之前安装的全局<code>hexo</code>命令，方法见下面。我主要修改了代码块高亮（highlight）生成，以及修复了始终会生成Read more链接的BUG，不过我会尽快发起pull request到hexo的。</span>  </p>
<p>另外，如果需要使用多说评论框，可以使用我的自定义多说评论框样式，主要保持了和Modernist theme的样式统一。请猛戳<a href="https://gist.github.com/heroicyang/5644407" target="_blank" rel="external">这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天偶然发现了一个Github Page主题：<a href="http://orderedlist.github.io/modernist/" target="_blank" rel="external">Modernist</a>，觉着很舒服。作者将其开源在Githu]]>
    </summary>
    
      <category term="hexo" scheme="http://heroicyang.com/tags/hexo/"/>
    
      <category term="modernist" scheme="http://heroicyang.com/tags/modernist/"/>
    
      <category term="theme" scheme="http://heroicyang.com/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript设计模式》阅读笔记]]></title>
    <link href="http://heroicyang.com/2013/03/26/javascript-design-pattern-notes/"/>
    <id>http://heroicyang.com/2013/03/26/javascript-design-pattern-notes/</id>
    <published>2013-03-26T15:42:35.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>最近总算是把《JavaScript设计模式》这本书给认认真真啃完了，受益匪浅。虽然已经是几年前的出版物了，而且也没得地方可以买到，但是我个人觉得这本书是JavaScript程序员必读书籍之一。如果没有读过，建议一读，绝对不会让你失望。  </p>
<p>而可能有一些地方的翻译让人一开始有点迷糊，比如我们常说的“单例模式”被译为“单体模式”，而“mixin class”被译为“掺元类”。但是对于我这种E文能力弱的人来说，完全没有挑剔的地方。  </p>
<p>我在读这本书的时候，采取了一些阅读方式来加深理解，个人感觉还过得去，就简单的分享下。我每两天完成一章节，第一天阅读整个章节的内容，边理解边对照着写实例代码；之后若是一有时间，大脑就温习这次的内容；第二天则主动回忆前一天所阅读的内容，整理简要的笔记纲要，并按照个人的理解和笔记纲要再写一次实例代码。  </p>
<p>因此这本书读完之后，我的笔记也就随即产出了。我没有采用很长的篇幅记录，而是思维导图来整理每一章的内容，这样也方便日后温习。  </p>
<p>呃，好久也没有写博客了，所以将笔记也一并分享出来，也欢迎大家分享自己的学习方法和笔记方法。<br><a id="more"></a>  </p>
<p><a href="http://cl.ly/3p383r2V1M0Z" target="_blank" rel="external">我将思维导图导出成pdf版本了，需要的自取吧！</a>  </p>
<p>顺便也放张预览图，不过有点大。</p>
<p><img src="http://img.heroicyang.com/JavaScript-Design-Pattern-Notes.png" alt="《JavaScript设计模式》读书笔记"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近总算是把《JavaScript设计模式》这本书给认认真真啃完了，受益匪浅。虽然已经是几年前的出版物了，而且也没得地方可以买到，但是我个人觉得这本书是JavaScript程序员必读书籍之一。如果没有读过，建议一读，绝对不会让你失望。  </p>
<p>而可能有一些地方的翻译让人一开始有点迷糊，比如我们常说的“单例模式”被译为“单体模式”，而“mixin class”被译为“掺元类”。但是对于我这种E文能力弱的人来说，完全没有挑剔的地方。  </p>
<p>我在读这本书的时候，采取了一些阅读方式来加深理解，个人感觉还过得去，就简单的分享下。我每两天完成一章节，第一天阅读整个章节的内容，边理解边对照着写实例代码；之后若是一有时间，大脑就温习这次的内容；第二天则主动回忆前一天所阅读的内容，整理简要的笔记纲要，并按照个人的理解和笔记纲要再写一次实例代码。  </p>
<p>因此这本书读完之后，我的笔记也就随即产出了。我没有采用很长的篇幅记录，而是思维导图来整理每一章的内容，这样也方便日后温习。  </p>
<p>呃，好久也没有写博客了，所以将笔记也一并分享出来，也欢迎大家分享自己的学习方法和笔记方法。<br>]]>
    
    </summary>
    
      <category term="design pattern" scheme="http://heroicyang.com/tags/design-pattern/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解JavaScript定时器（续）]]></title>
    <link href="http://heroicyang.com/2012/10/14/javascript-timer-and-event-in-depth/"/>
    <id>http://heroicyang.com/2012/10/14/javascript-timer-and-event-in-depth/</id>
    <published>2012-10-14T14:50:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>对于浏览器端来说，大多数事件都是异步的，但是有部分事件却不是，这部分事件称做<strong>同步事件</strong>，因此它们都是立即执行的，完全不理会前几篇文章中所提到的<strong>事件队列</strong>。以及浏览器的渲染、重绘等操作，也会打乱之前我们好不容易所建立起来的<strong>事件队列</strong>的概念。不过，本篇将会陆续不断的把这些坑给填上。  </p>
<h2 id="同步事件">同步事件</h2><h3 id="DOM改变事件(DOM_Mutation_events)">DOM改变事件(DOM Mutation events)</h3><p>下面的Demo便用于说明同步事件之一的<code>DOM Mutation events</code>（注：该事件不支持Chrome浏览器）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://heroicyang.com/"</span>&gt;</span></span><br><span class="line">  heroicyang.com</span><br><span class="line"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="pf"></span><br><span class="line">  var <span class="built_in">anchor</span> = document.getElementsByTagName('a')[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">anchor</span>.onclick = function(e) &#123;</span><br><span class="line">    alert('<span class="keyword">in</span> onclick');</span><br><span class="line">    this.<span class="built_in">set</span>Attribute('href', '<span class="comment">#');</span></span><br><span class="line">    alert('<span class="keyword">out</span> onclick');</span><br><span class="line">    return false;</span><br><span class="line">  &#125;;</span><br><span class="line">  if (<span class="built_in">anchor</span>.addEventListener) &#123;  //Firefox, Opera</span><br><span class="line">    <span class="built_in">anchor</span></span><br><span class="line">      .addEventListener('DOMAttrModified', onpropchange, false);</span><br><span class="line">  &#125; else if (<span class="built_in">anchor</span>.attachEvent) &#123;  //IE</span><br><span class="line">    <span class="built_in">anchor</span></span><br><span class="line">      .attachEvent('onpropertychange', onpropchange);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function onpropchange() &#123;</span><br><span class="line">    alert('onpropchange');</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当<code>click</code>事件触发时，其处理的顺序依次为：</p>
<ol>
<li>alert <code>in onclick</code>  </li>
<li>超链接的属性立即被改变，并alert <code>onpropchange</code>  </li>
<li>继续执行<code>onclick</code>事件处理程序中剩下的 <code>alert(&#39;out onclick&#39;);</code>  </li>
</ol>
<p><img src="http://img.heroicyang.com/synchronous-mutation-events.png" alt=""><br>关于<code>DOM Mutation events</code>，详情请参见：<br><a href="https://developer.mozilla.org/en-US/docs/DOM/Mutation_events" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/DOM/Mutation_events</a><br><a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents" target="_blank" rel="external">http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents</a>  </p>
<h3 id="嵌套的DOM事件">嵌套的DOM事件</h3><p>在浏览器端，有一些方法会立即触发某类事件，而这类事件也是同步的。比如<code>element.focus()</code>，下面是演示代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"click me"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line">    , text = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  btn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in onclick'</span>);</span><br><span class="line">    text.focus();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out onclick'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  text.onfocus = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onfocus'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>执行结果如下：</p>
<p><img src="http://img.heroicyang.com/synchronous-focus-event.png" alt="">  </p>
<p>常规情况下，事件处理都是一个一个执行的，而我们也就假定一个事件开始时，前一个事件是执行完毕了的。而以上这些同步事件不仅打破了我们的常规认识，还会给我们带来一些负面效应。不过我们依旧可以使用<a href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth" target="_blank" rel="external">上一篇</a>中所使用的<code>setTimeout(func, 0)</code>来解决。  </p>
<h2 id="JavaScript执行与页面渲染">JavaScript执行与页面渲染</h2><p>大多数浏览器中，JavaScript的执行和页面渲染是互斥的，于是JavaScript执行时，浏览器就不会做任何的页面渲染。比如下面的Demo…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en-US"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span>JavaScript执行与页面渲染<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css"></span><br><span class="line">    <span class="id">#container</span> <span class="rules">&#123;</span><br><span class="line">      <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; </span><br><span class="line">      <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; </span><br><span class="line">      <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#A00000</span></span></span>; </span><br><span class="line">      <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">    &#125;</span></span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"container"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="keyword">var</span> runBtn = <span class="built_in">document</span>.getElementById(<span class="string">'run'</span>)</span><br><span class="line">      , container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">    </span><br><span class="line">    runBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0xA00000</span>; i &lt; <span class="number">0xFFFFFF</span>; i++) &#123;</span><br><span class="line">        container.style.backgroundColor = <span class="string">'#'</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<iframe src="http://sample.heroicyang.com/repaint.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:150px; padding: 1px;"></iframe>

<p>运行上面的Demo后，大多数浏览器都会假死了，直到<code>container</code>的背景颜色变更为<code>#FFFFFF</code>后才恢复。而有的浏览器(如Firefox)还会弹出警告，告知JavaScript没有响应，是终止还是等待。但是Opera却能正常运行，并不断更改背景颜色。因此不同浏览器对页面渲染和JavaScript执行的实现方式是不一样的。  </p>
<p>关于这方面有很大的学问，还需要继续学习，慢慢摸索。So…这个就点到为止了。</p>
<h3 id="模式对话框的同步调用">模式对话框的同步调用</h3><p>浏览器提供的如<code>alert</code>等的模式对话框是同步调用的，所以当这类对话框工作时，会停止<code>JavaScript线程</code>，当然如页面渲染等活动也将被冻结。继续下面的Demo…当运行代码下面的<code>iframe</code>中的进度条后，无论是点击<code>主窗体中的alert</code>按钮，还是点击<code>iframe中的alert</code>按钮，都会导致进度条挂起。  </p>
<p><input type="button" value="主窗体中的alert" onclick="alert('主窗体对话框');"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span> style=<span class="string">"width: 0px; height: 20px; background-color: #A00000;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"stop"</span> <span class="attribute">id</span>=<span class="value">"stop"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"iframe中的alert"</span> <span class="attribute">onclick</span>=<span class="value">"alert('iframe中的对话框');"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> runBtn = <span class="built_in">document</span>.getElementById(<span class="string">'run'</span>)</span><br><span class="line">    , stopBtn = <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>)</span><br><span class="line">    , container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  runBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> style = container.style;</span><br><span class="line">      style.width = (<span class="built_in">parseInt</span>(style.width) + <span class="number">2</span>) % <span class="number">400</span> + <span class="string">'px'</span>;</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  stopBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<iframe src="http://sample.heroicyang.com/modal-sync.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:70px; padding: 1px;"></iframe>  

<p>因此，浏览器所提供的<code>alert</code>、<code>confirm</code>、<code>prompt</code>这三类模式对话框，都会阻塞<code>JavaScript线程</code>和<code>UI线程</code>。  </p>
<p><strong>依旧，Opera有一点点的例外。。。</strong>  </p>
<p>在Opera中，点击<code>主窗体中的alert</code>按钮不会阻塞<code>iframe</code>中的进度条。。。又打破我们的常规认识啊：同一个页面上，<code>iframe</code>是和主窗体同一个线程的。但Opera的设计并非如此。。。  </p>
<h2 id="当脚本需要花很长的时间干复杂的工作时">当脚本需要花很长的时间干复杂的工作时</h2><p>类似的就是前面那个阻塞我们浏览器的，频繁更改<code>container</code>背景颜色的例子。最后，我们还是用<a href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth" target="_blank" rel="external">上一篇文章中</a>的<code>setTimeout(func, 0)</code>来解决它吧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"stop"</span> <span class="attribute">id</span>=<span class="value">"stop"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> runBtn = <span class="built_in">document</span>.getElementById(<span class="string">'run'</span>)</span><br><span class="line">    , stopBtn = <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>)</span><br><span class="line">    , container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0xA00000</span>, timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  runBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      timer = setTimeout(run, <span class="number">0</span>);</span><br><span class="line">      container.style.backgroundColor = <span class="string">'#'</span> + i.toString(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) stop();</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(run, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  stopBtn.onclick = stop;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<iframe src="http://sample.heroicyang.com/heavy-jobs.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:150px; padding: 1px;"></iframe>  

<p>最后，总结一下<code>setTimeout(func, 0)</code>的使用场景吧：</p>
<ol>
<li>让浏览器渲染当前的变化  </li>
<li>避免长时间运行的脚本  </li>
<li>流程控制  </li>
<li>等等等等。。。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于浏览器端来说，大多数事件都是异步的，但是有部分事件却不是，这部分事件称做<strong>同步事件</strong>，因此它们都是立即执行的，完全不理会前几篇文章中所提到的<strong>事件队列</strong>。以及浏览器的渲染、重绘等操作，也会打乱之前我们好不容易所建立起来的<strong>事件队列</strong>的概念。不过，本篇将会陆续不断的把这些坑给填上。  </p>
<h2 id="同步事件">同步事件</h2><h3 id="DOM改变事件(DOM_Mutation_events)">DOM改变事件(DOM Mutation events)</h3><p>下面的Demo便用于说明同步事件之一的<code>DOM Mutation events</code>（注：该事件不支持Chrome浏览器）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://heroicyang.com/"</span>&gt;</span></span><br><span class="line">  heroicyang.com</span><br><span class="line"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="pf"></span><br><span class="line">  var <span class="built_in">anchor</span> = document.getElementsByTagName('a')[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">anchor</span>.onclick = function(e) &#123;</span><br><span class="line">    alert('<span class="keyword">in</span> onclick');</span><br><span class="line">    this.<span class="built_in">set</span>Attribute('href', '<span class="comment">#');</span></span><br><span class="line">    alert('<span class="keyword">out</span> onclick');</span><br><span class="line">    return false;</span><br><span class="line">  &#125;;</span><br><span class="line">  if (<span class="built_in">anchor</span>.addEventListener) &#123;  //Firefox, Opera</span><br><span class="line">    <span class="built_in">anchor</span></span><br><span class="line">      .addEventListener('DOMAttrModified', onpropchange, false);</span><br><span class="line">  &#125; else if (<span class="built_in">anchor</span>.attachEvent) &#123;  //IE</span><br><span class="line">    <span class="built_in">anchor</span></span><br><span class="line">      .attachEvent('onpropertychange', onpropchange);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function onpropchange() &#123;</span><br><span class="line">    alert('onpropchange');</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="javascript timer" scheme="http://heroicyang.com/tags/javascript-timer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解JavaScript定时器]]></title>
    <link href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth/"/>
    <id>http://heroicyang.com/2012/09/22/javascript-timer-in-depth/</id>
    <published>2012-09-22T10:57:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>对于浏览器内部，大部分操作都是异步的生成事件并添加到<code>JavaScript引擎线程</code>的队列中，然后由<code>JavaScript引擎线程</code>进行调度执行。因此浏览器的很多事件都是和<code>JavaScript</code>相结合的，但是也有一些内部的限制。  </p>
<p>首先我们非常确定<code>JavaScript</code>是单线程的，对于浏览器来说，一个窗体中只有一个<code>JavaScript引擎线程</code>。而其他的行为，如：渲染、下载等是由单独的线程进行管理的，且具有不同的优先级。  </p>
<h2 id="异步事件">异步事件</h2><p>前面提到大多数事件都是异步的，触发的时候就将回调函数添加到事件队列。浏览器提供了一个内部的回路，也就是之前所谈到的<code>Event Loop</code>，由它来负责检查队列和处理事件、执行函数等。详细可参考我的<a href="http://heroicyang.com/2012/08/28/javascript-event-loop" target="_blank" rel="external">前一篇博文</a>。而<code>setTimeout</code>和<code>setInterval</code>也是将其需要执行的函数添加到事件队列。  </p>
<p><strong>事实上，大多数交互和活动都得通过事件循环。</strong><br><a id="more"></a>  </p>
<h2 id="事件重叠">事件重叠</h2><p>一些情况下，会有多个事件在同一时间附加到事件队列里。  </p>
<p>比如，<code>click</code>事件就会产生两个额外的事件：<code>mousedown</code>和<code>mouseup</code>。其中，<code>mouseup</code>和<code>click</code>事件会同时被添加到事件队列；而<code>mousedown</code>事件则很有可能会和另外一个事件重叠：<code>focus</code>。  </p>
<h2 id="setTimeout(func,_0)奇巧淫技">setTimeout(func, 0)奇巧淫技</h2><p>再一次解释关于<code>0ms</code>的误解：如果当前时钟周期内执行队列空闲，则立即执行该定时器，将回调函数加入到事件队列；然后等待下一个时钟周期，再执行该回调函数。不妨来看看下面的测试。</p>
<p>这段代码在我的浏览器中执行结果如下：</p>
<p><img src="http://img.heroicyang.com/setTimeout-Measure.png" alt=""></p>
<p>在我本地的<code>Nodejs</code>环境中执行结果如下：  </p>
<p><img src="http://img.heroicyang.com/setTimeout-Measure-Nodejs.png" alt="">  </p>
<p>上面的这个测试只是想说明<code>setTimeout(func, 0)</code>定时任务的回调函数执行时间是有延迟的，而并不是所谓的立即执行。  </p>
<p>因此，我们可以利用<code>setTimeout(func, 0)</code>来解决事件重叠所产生的负面效果，修正执行顺序。 </p>
<h3 id="奇巧淫技之一：模拟浏览器的事件捕获">奇巧淫技之一：模拟浏览器的事件捕获</h3><p>众所周知，浏览器的DOM事件都是采用冒泡的方式，只有个别浏览器是支持事件捕获的。而在实际的开发过程中可能存在需要事件捕获的需求，要求子元素的事件在父元素触发之后才能触发。为了兼容各个浏览器，我们不能使用事件捕获，而<code>setTimeout(func, 0)</code>在这个时候就很乐意帮忙了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"click"</span> id=<span class="string">"cbtn"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"result"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="nimrod"></span><br><span class="line">  <span class="keyword">var</span> cbtn = document.getElementById('cbtn')</span><br><span class="line">    , <span class="literal">result</span> = document.getElementById('<span class="literal">result</span>');</span><br><span class="line"></span><br><span class="line">  cbtn.onclick = function(e) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      <span class="literal">result</span>.innerHTML += 'input click, ';</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  document.body.onclick = function(e) &#123;</span><br><span class="line">    <span class="literal">result</span>.innerHTML += 'body click -&gt; ';</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>点击查看运行效果：  </p>
<iframe src="http://sample.heroicyang.com/setTimeout01.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:80px; padding: 1px;"></iframe>

<h3 id="奇巧淫技之二：让浏览器更好的工作">奇巧淫技之二：让浏览器更好的工作</h3><p>大多数情况下，我们可以在浏览器的默认行为之前对事件进行处理，但是有时我们按照常规的思路去做的时候，往往事与愿违。比如下面的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> wordInput = <span class="built_in">document</span>.getElementById(<span class="string">'wordInput'</span>);</span><br><span class="line">  wordInput.onkeypress = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>看似一个很简单的需求：每输入一个字符，就将其转换为大写。但是上面的代码完全没有按照指示去做，不信你试试看：  </p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-01.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>如果没有下一次输入，文本框中的小写字母永远都不会转换为大写。Why? 因为浏览器在<code>keypress</code>事件处理的时候，还没有将我们输入的值添加到文本框。于是乎换一个事件来handle然后再处理吧，既然键按下的时候还木有值，那就等键弹起来之后再处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> wordInput = <span class="built_in">document</span>.getElementById(<span class="string">'wordInput'</span>);</span><br><span class="line">  wordInput.onkeyup = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>运行试试吧。</p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-02.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>大概似乎是可行了，可是仔细观察就看出问题了。<code>keyup</code>事件触发时，文本框已经具备完整的值了，但先是一个小写的值，键完全释放之后转变为大写。这不科学…这太丑陋…  </p>
<p>是时候关门放出<code>setTimeout(func, 0)</code>了。。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  <span class="keyword">var</span> wordInput = document.getElementById(<span class="string">'wordInput'</span>);</span><br><span class="line">  wordInput.onkeypress = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">self</span>.value = <span class="keyword">self</span>.value.toUpperCase();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>  </p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-03.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>已经完美了。<code>keypress</code>事件触发时，将转换大写的操作添加到事件队列，紧接着浏览器添加我们输入的值，然后近乎0延迟的执行我们的转换大写操作函数。  </p>
<p>上面两个小案例只是冰山一角，so…合理利用<code>setTimeout(func, 0)</code>，明天更美好！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于浏览器内部，大部分操作都是异步的生成事件并添加到<code>JavaScript引擎线程</code>的队列中，然后由<code>JavaScript引擎线程</code>进行调度执行。因此浏览器的很多事件都是和<code>JavaScript</code>相结合的，但是也有一些内部的限制。  </p>
<p>首先我们非常确定<code>JavaScript</code>是单线程的，对于浏览器来说，一个窗体中只有一个<code>JavaScript引擎线程</code>。而其他的行为，如：渲染、下载等是由单独的线程进行管理的，且具有不同的优先级。  </p>
<h2 id="异步事件">异步事件</h2><p>前面提到大多数事件都是异步的，触发的时候就将回调函数添加到事件队列。浏览器提供了一个内部的回路，也就是之前所谈到的<code>Event Loop</code>，由它来负责检查队列和处理事件、执行函数等。详细可参考我的<a href="http://heroicyang.com/2012/08/28/javascript-event-loop">前一篇博文</a>。而<code>setTimeout</code>和<code>setInterval</code>也是将其需要执行的函数添加到事件队列。  </p>
<p><strong>事实上，大多数交互和活动都得通过事件循环。</strong><br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="javascript timer" scheme="http://heroicyang.com/tags/javascript-timer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解JavaScript定时器：setTimeout和setInterval]]></title>
    <link href="http://heroicyang.com/2012/09/06/javascript-timers/"/>
    <id>http://heroicyang.com/2012/09/06/javascript-timers/</id>
    <published>2012-09-06T14:56:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>定时器其实并不是<code>JavaScript</code>提供的，而是由浏览器（对于前端来说）提供的。</strong>所以<code>setTimeout()</code>和<code>setInterval()</code>这两个方法均是通过浏览器的顶层对象<code>window</code>进行调用，可能平时大家在使用的过程中也会省去<code>window</code>而直接使用这两个方法。  </p>
<p>这两个方法所接收的参数都一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func|code, delay);</span><br><span class="line">setInterval(func|code, delay);</span><br></pre></td></tr></table></figure><br>这两个方法总是被简单的认为：在多少毫秒之后就执行里面的函数或者每间隔多少毫秒就执行里面的函数，基于这种理解的话会遇到很多匪夷所思的坑。而结合<a href="http://heroicyang.com/2012/08/28/javascript-event-loop" target="_blank" rel="external">上篇文章</a>中所提到的执行队列来解释的话，很多疑问都可以迎刃而解。</p>
<p>前者：在指定的毫秒数后，将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。  </p>
<p>后者：按照指定的周期（以毫秒计），将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。<br><a id="more"></a><br>下面分别使用了<code>setInterval</code>和<code>setTimeout</code>来实现同一个功能，可运行查看效果。 </p>
<iframe src="http://sample.heroicyang.com/timer.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:80px;"></iframe>

<p>这是相应的源代码：<a href="http://code.heroicyang.com/timer.html" target="_blank">传送门</a>  </p>
<p><strong>接下来继续填<code>setInterval</code>的坑。</strong>  </p>
<p>假设定时器的上一个回调执行完到下一个回调开始的这段时间为时间间隔，那么对于<code>setTimeout</code>来说，这个时间间隔理论上是应该<code>&gt;=delay</code>；而对于<code>setInterval</code>来说，这个时间间隔理论上是应该<code>&lt;=delay</code>的。</p>
<p>但事实总会有出人意料的地方，<code>setInterval</code>就是那个制造意外的东西。   </p>
<p>以下是常规的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> endTime = <span class="literal">null</span>;</span><br><span class="line">setInterval(count, <span class="number">200</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> <span class="built_in">Date</span>() - endTime) : <span class="number">200</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);</span><br><span class="line">  endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其执行结果也比较符合理论时间，见下图。</p>
<p><img src="http://img.heroicyang.com/setInterval1.png" alt="">   </p>
<p>接下来修改代码，让<code>count()</code>方法的执行时间变长一点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> <span class="built_in">Date</span>() - endTime) : <span class="number">200</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);</span><br><span class="line">  sleep(<span class="number">100</span>); <span class="comment">//sleep 100ms</span></span><br><span class="line">  endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果如下：</p>
<p><img src="http://img.heroicyang.com/setInterval2.png" alt=""></p>
<p>结合执行队列，可以用下图对上面两种情况进行直观的解释：</p>
<p><img src="http://img.heroicyang.com/setInterval1-explain.png" alt="">   </p>
<p>接下来再次修改代码，让<code>count()</code>方法的执行时间更长，设定为<code>setInterval</code>中<code>delay</code>的<code>2</code>倍，即<code>400ms</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> <span class="built_in">Date</span>() - endTime) : <span class="number">200</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);</span><br><span class="line">  sleep(<span class="number">400</span>); <span class="comment">//sleep 400ms</span></span><br><span class="line">  endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其执行效果变为如下：</p>
<p><img src="http://img.heroicyang.com/setInterval3.png" alt="">  </p>
<p>意外发生了，每个回调之间的时间间隔竟然没有了，或者说缩短到非常小的间隔。事情大概是这样的：如果<code>setInterval</code>的定时时间到了，而前一个回调还没有执行完时，就会把这次的回调放在执行队列的队尾；如果<code>setInterval</code>的定时时间已经多次触发，而此时最前一个回调仍然还在执行，那么就会丢弃掉本次的回调。还是用图来直观说明吧。  </p>
<p>这是回调处理时间比定时时间稍微长一点点的情况：</p>
<p><img src="http://img.heroicyang.com/setInterval2-explain.png" alt="">  </p>
<p>这是回调处理时间比定时时间长很多的情况：</p>
<p><img src="http://img.heroicyang.com/setInterval3-explain.png" alt="">  </p>
<p><strong>所以，如果使用<code>setInterval</code>的话，其时间间隔总是让人捉摸不定。而使用<code>setTimeout</code>嵌套，则完全可以解决这个问题，还我们一个固定的时间间隔。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>定时器其实并不是<code>JavaScript</code>提供的，而是由浏览器（对于前端来说）提供的。</strong>所以<code>setTimeout()</code>和<code>setInterval()</code>这两个方法均是通过浏览器的顶层对象<code>window</code>进行调用，可能平时大家在使用的过程中也会省去<code>window</code>而直接使用这两个方法。  </p>
<p>这两个方法所接收的参数都一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func|code, delay);</span><br><span class="line">setInterval(func|code, delay);</span><br></pre></td></tr></table></figure><br>这两个方法总是被简单的认为：在多少毫秒之后就执行里面的函数或者每间隔多少毫秒就执行里面的函数，基于这种理解的话会遇到很多匪夷所思的坑。而结合<a href="http://heroicyang.com/2012/08/28/javascript-event-loop">上篇文章</a>中所提到的执行队列来解释的话，很多疑问都可以迎刃而解。</p>
<p>前者：在指定的毫秒数后，将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。  </p>
<p>后者：按照指定的周期（以毫秒计），将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="javascript timer" scheme="http://heroicyang.com/tags/javascript-timer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Event Loop 浅析]]></title>
    <link href="http://heroicyang.com/2012/08/28/javascript-event-loop/"/>
    <id>http://heroicyang.com/2012/08/28/javascript-event-loop/</id>
    <published>2012-08-28T14:52:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习<code>Nodejs</code>的过程中深入的了解了<code>异步编程</code>这个概念，为了更好的使用<code>Nodejs</code>，这些概念不可不知。在以前作为一个<code>JavaScript</code>用户的时候，完全是不知道它是怎么运行的，对好些概念也是“知其然不知其所以然”。  </p>
<p>对于客户端的<code>JavaScript</code>和<code>Nodejs</code>来说其实差距不是很大，这回就从客户端方面来说说<code>Event Loop</code>这个概念吧，算是<code>异步编程</code>的一个切入点吧。其实<code>jQuery</code>的作者John Resig在几年前就写了一篇好文章<a href="http://ejohn.org/blog/how-javascript-timers-work/" target="_blank" rel="external">How JavaScript Timers Work</a>，来讲述<code>timer</code>和<code>事件</code>在浏览器中是怎样工作的，我也是通过这篇文章才“知其所以然”。  </p>
<h3 id="问题场景">问题场景</h3><p>先来看看一段代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span> <span class="attribute">id</span>=<span class="value">"doBtn"</span>&gt;</span>do something<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"status"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doBtn = <span class="built_in">document</span>.getElementById(<span class="string">'doBtn'</span>)</span><br><span class="line">      , status = <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>);</span><br><span class="line"></span><br><span class="line">    doBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line"></span><br><span class="line">      status.innerText = <span class="string">'doing...please wait...'</span>;  <span class="comment">//开始啦</span></span><br><span class="line">      sleep(<span class="number">10000</span>);  <span class="comment">//模拟一个耗时较长的计算过程，10s</span></span><br><span class="line">      status.innerText = <span class="string">'done'</span>;  <span class="comment">//完成啦</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt;= ms) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码主要想完成一个功能：按钮被点击时———&gt;显示一个状态告知用户正在干一些事情———&gt;开始干———&gt;事情干完后状态变更为已完成。<br><a id="more"></a></p>
<p>看上去没问题，应该是可以工作的，于是在浏览器运行这个页面。可是现实总是残忍的，没有符合预期效果。当点击按钮之后，浏览器就冻结了，用于显示状态的<code>div</code>并没有显示，界面上也没有“doing…”这个提示；经过<code>10s</code>之后，浏览器回过神了，代表耗时较长的计算已经结束，此时用于显示状态的<code>div</code>显示“done”。  </p>
<p>究其原因：JavaScript引擎是单线程的。而此时还有必要再了解下浏览器内核都有哪些主要的常驻线程，才能解上面的疑惑。浏览器内核常驻线程大致包含以下：  </p>
<ol>
<li>浏览器GUI渲染线程</li>
<li>JavaScript引擎线程</li>
<li>浏览器定时触发器线程</li>
<li>浏览器事件触发线程</li>
<li>浏览器http异步请求线程</li>
</ol>
<p>而GUI渲染线程和JavaScript引擎线程是互斥的，JavaScript执行时GUI渲染线程是挂起的，页面将停止一切的解析和渲染行为。上面的3、4、5类线程也会产生不同的异步事件。看下面这张图就应该比较直观了。</p>
<p><img src="http://img.heroicyang.com/js-event-loop.png" alt="JavaScript-Event-Loop"></p>
<p>因为JavaScript引擎是单线程的，所以代码都是先压到队列，然后由引擎采用先进先出的方式运行。事件处理函数、timer执行函数也会排到这个队列中，然后利用一个无穷回圈，不断从队头取出函数执行，这个就是<code>Event Loop</code>。  </p>
<p>接下来还是继续用图来说明上面的代码为什么没有达到预期效果。</p>
<p><img src="http://img.heroicyang.com/js-event-loop-1.png" alt=""></p>
<p>于是结果就只看到了”done”。  </p>
<h3 id="怎样解决？">怎样解决？</h3><p>使用<code>setTimeout()</code>，下面是修改后的<code>onclick</code>事件处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">doBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  status.innerText = <span class="string">'doing...please wait...'</span>;  <span class="comment">//开始啦</span></span><br><span class="line">  </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">10000</span>);  <span class="comment">//模拟一个耗时较长的计算过程，10s</span></span><br><span class="line">    status.innerText = <span class="string">'done'</span>;  <span class="comment">//完成啦</span></span><br><span class="line">  &#125;, <span class="number">0</span>);  <span class="comment">// 0ms delay</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么这样就解决了呢？还是用上面的队列的图来解释。</p>
<p><img src="http://img.heroicyang.com/js-event-loop-2.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习<code>Nodejs</code>的过程中深入的了解了<code>异步编程</code>这个概念，为了更好的使用<code>Nodejs</code>，这些概念不可不知。在以前作为一个<code>JavaScript</code>用户的时候，完全是不知道它是怎么运行的，对好些概念也是“知其然不知其所以然”。  </p>
<p>对于客户端的<code>JavaScript</code>和<code>Nodejs</code>来说其实差距不是很大，这回就从客户端方面来说说<code>Event Loop</code>这个概念吧，算是<code>异步编程</code>的一个切入点吧。其实<code>jQuery</code>的作者John Resig在几年前就写了一篇好文章<a href="http://ejohn.org/blog/how-javascript-timers-work/">How JavaScript Timers Work</a>，来讲述<code>timer</code>和<code>事件</code>在浏览器中是怎样工作的，我也是通过这篇文章才“知其所以然”。  </p>
<h3 id="问题场景">问题场景</h3><p>先来看看一段代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span> <span class="attribute">id</span>=<span class="value">"doBtn"</span>&gt;</span>do something<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"status"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doBtn = <span class="built_in">document</span>.getElementById(<span class="string">'doBtn'</span>)</span><br><span class="line">      , status = <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>);</span><br><span class="line"></span><br><span class="line">    doBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line"></span><br><span class="line">      status.innerText = <span class="string">'doing...please wait...'</span>;  <span class="comment">//开始啦</span></span><br><span class="line">      sleep(<span class="number">10000</span>);  <span class="comment">//模拟一个耗时较长的计算过程，10s</span></span><br><span class="line">      status.innerText = <span class="string">'done'</span>;  <span class="comment">//完成啦</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt;= ms) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码主要想完成一个功能：按钮被点击时———&gt;显示一个状态告知用户正在干一些事情———&gt;开始干———&gt;事情干完后状态变更为已完成。<br>]]>
    
    </summary>
    
      <category term="event-loop" scheme="http://heroicyang.com/tags/event-loop/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="javascript timer" scheme="http://heroicyang.com/tags/javascript-timer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[像黑客一样写博客]]></title>
    <link href="http://heroicyang.com/2012/08/26/blogging-like-a-hacker/"/>
    <id>http://heroicyang.com/2012/08/26/blogging-like-a-hacker/</id>
    <published>2012-08-26T15:24:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>“像黑客一样写博客”，这个标题是网络上对<code>Octopress</code>（其实应该是<code>Jekyll</code>）的评价，而这一评价是来自一篇几年前的<a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html" target="_blank" rel="external">文章</a>。当我将自己的博客抹掉并重新开始的时候，我也准备以这个标题来作为这次的新起点。  </p>
<p>其实早就有换掉<code>WordPress</code>的想法，一是因为它太臃肿了，我只是想简单的写写博客，用不着那么多强大的功能；二是它对插入代码的支持让我绝望了，每次用<code>Markdown</code>写好文章，复制其<code>HTML</code>到<code>WordPress</code>之后，都要调整好半天的样式；三是我之前的博客中太多的碎碎念之类的水文了，可谓杂、乱，并不像一个记录技术的博客。综合这些借口，我每次登录到<code>WordPress</code>后台都没有再写文章的激情。<br><a id="more"></a><br>而之前我也和<a href="http://veryb.us/" target="_blank" rel="external">fiture</a>聊到用<a href="http://heroicyang.com/tags/nodejs/" target="_blank" rel="external">Nodejs</a>来重新写个博客，也当学习练手。经过间歇性的聊聊之后，我提议说不弄数据库了，直接将文章以<code>Markdown</code>的格式<code>push</code>到<code>Github</code>吧等等的初步想法。当时我们觉得还不错，因为也没了解过有没有这样的东西存在，之后我下意识地搜了下。结果发现了<code>OctoPress</code>这个东西，了解之后感觉完全正合我意啊，所以二话不说就直接给换上了。  </p>
<p>于是我总算是终于弃掉了<code>WordPress</code>，用上<code>Octopress</code>这个高级货，可谓得心应手。  </p>
<p>其实我也就冲着我认为的这几点优势：</p>
<ol>
<li>直接使用<code>Markdown</code>写文章</li>
<li>全站静态化，根据<code>Markdown</code>生成文章的静态页面</li>
<li>所以直接在<code>Terminal</code>把文章<code>push</code>到我的<a href="https://github.com/heroicYang/heroicyang.com" target="_blank" rel="external">Github</a>上即可，有版本管理真好</li>
<li>然后加之<code>Github Page</code>的支持，虽然有一些些小问题，比如<code>缓存</code>，但瑕不掩瑜</li>
<li>整个写作过程和写代码的过程是一致的，符合码农的行为习惯，也就是所谓的“像黑客一样写博客”</li>
</ol>
<p>这样，就只需要一个<code>Markdown</code>编辑器（推荐<a href="http://mouapp.com/" target="_blank" rel="external">Mou</a>和<a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a>），再配合终端的<code>git</code>命令就OK了，其余的都不用管了，交给第三方去。比如：评论系统我就采用了国内的<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>；然后用<a href="http://dropbox.com/" target="_blank" rel="external">Dropbox</a>来保存文章中会用到的图片，因为<code>Dropbox</code>被<code>GFW</code>认证，所以再利用<a href="http://en.wikipedia.org/wiki/Nginx" target="_blank" rel="external">Nginx</a>做个<a href="http://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="external">反向代理</a>。一切都妥妥的了。  </p>
<p>以前博客的那些废柴文章都不要了，不过还是做了个备份，算是纪念好了。而把近期写的3篇与<a href="http://heroicyang.com/tags/javascript/" target="_blank" rel="external">JavaScript</a>相关的文章转移了过来，重新开始技术博客的历程，见证成长。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>“像黑客一样写博客”，这个标题是网络上对<code>Octopress</code>（其实应该是<code>Jekyll</code>）的评价，而这一评价是来自一篇几年前的<a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html">文章</a>。当我将自己的博客抹掉并重新开始的时候，我也准备以这个标题来作为这次的新起点。  </p>
<p>其实早就有换掉<code>WordPress</code>的想法，一是因为它太臃肿了，我只是想简单的写写博客，用不着那么多强大的功能；二是它对插入代码的支持让我绝望了，每次用<code>Markdown</code>写好文章，复制其<code>HTML</code>到<code>WordPress</code>之后，都要调整好半天的样式；三是我之前的博客中太多的碎碎念之类的水文了，可谓杂、乱，并不像一个记录技术的博客。综合这些借口，我每次登录到<code>WordPress</code>后台都没有再写文章的激情。<br>]]>
    
    </summary>
    
      <category term="blog" scheme="http://heroicyang.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript中创建类的方式]]></title>
    <link href="http://heroicyang.com/2012/08/19/create-class-in-javascript/"/>
    <id>http://heroicyang.com/2012/08/19/create-class-in-javascript/</id>
    <published>2012-08-18T17:05:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>现在<code>JavaScript</code>这门技术已经到了一个引爆点，一年前我对它的了解都只停留在肤浅的网页客户端脚本语言，只会简单的玩玩<code>jQuery</code>和<code>ExtJs</code>，其实都算不上开发者，而是一个<code>JavaScript</code>用户。但今年的目标是做一个合格的前端攻城湿，所以恶补是必须的。  </p>
<p>在<code>JavaScript</code>中是其实不存在所谓“类”的概念，因为它并不是面向对象的语言。在面向对象中，一个最常见的说法就是：“类”是“对象”的模板，基本上都是采用语言内置的<code>Class</code>或<code>class</code>关键字来定义“类”。而<code>JavaScript</code>不存在这个概念，所以也没有提供类似的关键字（虽然<code>class</code>是<code>JavaScript</code>的关键字，但是至今都没有实现，只是被保留而已）。  </p>
<p>因此，在<code>JavaScript</code>中创建类就唯有使用模拟的方式，而模拟的手法多种多样，何时采用何种方式最合适，需视情况而定。以下就记录下常见的几种模式。<br><a id="more"></a></p>
<h3 id="一-工厂模式">一.工厂模式</h3><p>工厂方法是设计模式中非常基础的，也被广泛用于面向对象编程中。而在<code>JavaScript</code>中，通过工厂方法即能模拟出类的行为。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span><span class="params">(name, sex, …)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.sex = sex;</span><br><span class="line">  …</span><br><span class="line">  obj.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personA = createPerson(<span class="string">'heroicYang'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> personB = createPerosn(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);</span><br></pre></td></tr></table></figure><br>通过这样类似的工厂方法，就可以创建出多个相似的对象了，但是这样的方式其抽象度极低。面向对象编程中，对象是可以检测出类型的，但是采用上面这种方式，是没有办法进行对象类型识别的。</p>
<h3 id="二-构造函数模式">二.构造函数模式</h3><p>其实，这应该是很常见的模式了，很多书上基本上一来就是讲这个的，更狠点的可能就只讲这个…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, sex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'heroic'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);</span><br></pre></td></tr></table></figure><br>这种模拟类方式的特点就是:</p>
<ol>
<li>没有显示的创建对象   </li>
<li>直接将属性和方法赋给了<code>this</code>对象    </li>
<li>没有<code>return</code>字句</li>
</ol>
<p>在使用这种方式时，创建对象则必须使用<code>new</code>关键字。当然，好处就是完全解决了对象类型识别问题。</p>
<h3 id="三-原型模式">三.原型模式</h3><p>原型应该是<code>JavaScript</code>中一个很有意思，当然也是很有用的一个概念了。接下来用原型模式来模拟类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="literal">null</span>,</span><br><span class="line">  sex: <span class="literal">null</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> personA = <span class="keyword">new</span> Person;</span><br><span class="line">personA.name = <span class="string">'heroic'</span>;</span><br><span class="line">personA.sex = <span class="string">'male'</span>;</span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person;</span><br><span class="line">personB.name = <span class="string">'路人甲'</span>;</span><br><span class="line">personB.sex = <span class="string">'male'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="四-组合使用构造函数和原型模式">四.组合使用构造函数和原型模式</h3><p>由于只用原型模式的话，会带来一些问题，所以常规情况下，都是采用组合构造函数和原型模式来创建类，这也是使用率最高的一种方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, sex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'heroic'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);</span><br><span class="line">personA.getName(); <span class="comment">//"heroic"</span></span><br><span class="line">personB.getName(); <span class="comment">//"路人甲"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="五-寄生构造函数模式">五.寄生构造函数模式</h3><p>这种模式和工厂模式非常相似。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">  values.toPipString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> SpecialArray(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>);</span><br><span class="line">test.toPipString(); <span class="comment">// "1|2|3"</span></span><br></pre></td></tr></table></figure><br>这种模式主要用来扩展一些对象的行为，而又不会对这个对象造成污染。当然，上面的代码也是可以直接为<code>Array.prototype</code>原型对象添加一个<code>toPipString()</code>方法来完成的，但是这样就造成了对<code>JavaScript</code>原生对象的污染。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在<code>JavaScript</code>这门技术已经到了一个引爆点，一年前我对它的了解都只停留在肤浅的网页客户端脚本语言，只会简单的玩玩<code>jQuery</code>和<code>ExtJs</code>，其实都算不上开发者，而是一个<code>JavaScript</code>用户。但今年的目标是做一个合格的前端攻城湿，所以恶补是必须的。  </p>
<p>在<code>JavaScript</code>中是其实不存在所谓“类”的概念，因为它并不是面向对象的语言。在面向对象中，一个最常见的说法就是：“类”是“对象”的模板，基本上都是采用语言内置的<code>Class</code>或<code>class</code>关键字来定义“类”。而<code>JavaScript</code>不存在这个概念，所以也没有提供类似的关键字（虽然<code>class</code>是<code>JavaScript</code>的关键字，但是至今都没有实现，只是被保留而已）。  </p>
<p>因此，在<code>JavaScript</code>中创建类就唯有使用模拟的方式，而模拟的手法多种多样，何时采用何种方式最合适，需视情况而定。以下就记录下常见的几种模式。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="javascript class" scheme="http://heroicyang.com/tags/javascript-class/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Backbone之旅：前端MVC架构初体验（下）]]></title>
    <link href="http://heroicyang.com/2012/08/09/to-backbone-tutorial-2/"/>
    <id>http://heroicyang.com/2012/08/09/to-backbone-tutorial-2/</id>
    <published>2012-08-08T16:59:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>继<a href="http://heroicyang.com/2012/08/08/to-backbone-tutorial-1" target="_blank" rel="external">《Backbone之旅：前端MVC架构初体验（上）》</a>，上篇中最后的代码已经完全达到最初提出的几点要求，现在就结合<code>Backbone</code>提供的能力，来继续精简代码。最后的目标就是将上篇中的代码全部重构为<code>Backbone</code>的<code>MVC</code>模式。  </p>
<p>上篇中最后一次改造就已经使用到了<code>callback</code>的方式，所以我们索性再加上<code>Event</code>机制吧，因为<code>Backbone</code>内置了这个能力。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = _.clone(Backbone.Events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add(&#123;</span><br><span class="line">    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后面不变*/</span></span><br></pre></td></tr></table></figure><br>现在既然调用<code>add()</code>时传入的<code>success</code>属性已经完全不涉及到<code>DOM</code>操作了，而是单纯的事件触发，那完全可以把这个行为放置到<code>TodoList</code>原型的<code>add()</code>方法中去了，这样重用性更高。  </p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: todoContent &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* … */</span></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add($(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* … */</span></span><br></pre></td></tr></table></figure>  
<p>接下来，咱看看在<code>NewTodoView</code>这个视图中事件订阅所触发的对应方法<code>appendTodo()</code>和<code>clearTextArea()</code>中，涉及到的是处在同一级别的不同的<code>DOM</code>元素节点，也就是说在<code>NewTodoView</code>这个视图中，我们处理了两个<code>DOM</code>元素，这似乎和我们之前提到的“单一职责原则”相违背了，所以还有待进一步的改进。  </p>
<p>我们分别把新增<code>Todo</code>的视图和负责展示<code>Todo Item</code>的视图分开定义，使其符合“单一职责原则”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前面不变 */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add($(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.clearTextArea = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于展示Todo Item */</span></span><br><span class="line"><span class="keyword">var</span> TodoView = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TodoView.prototype.appendTodo = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用程序启动 */</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; todoList: todoList &#125;);</span><br><span class="line">  <span class="keyword">new</span> TodoView();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>现在每个<code>View</code>里面只依赖一个顶层的<code>HTML Element</code>了，而在各自的<code>View</code>里面多次使用到了<code>$(&#39;#new-todo&#39;)</code>这样的代码，所以干脆将其在初始化的时候作为<code>View</code>的一个属性来提供吧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前面依旧不变 */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line">  <span class="keyword">this</span>.el = $(<span class="string">'#new-todo'</span>);  <span class="comment">//定义一个el属性ß</span></span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.el.find(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.el.find(<span class="string">'textarea'</span>).val());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.clearTextArea = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el.find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el = $(<span class="string">'#todo-list'</span>);</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TodoView.prototype.appendTodo = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el.find(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 后面不变 */</span></span><br></pre></td></tr></table></figure><br>此时观察发现，两个<code>View</code>当中还保留着对<code>DOM</code>节点的依赖，其重用度依然不高，于是可采用实例化<code>View</code>的时候传入<code>el</code>参数来解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前面不变 */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line">  <span class="keyword">this</span>.el = options.el;</span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.el.find(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* NewTodoView的原型方法也不变 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el = options.el;</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* TodoView的原型方法也不变 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化View的时候传入el */</span>	</span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; el: $(<span class="string">'#new-todo'</span>), todoList: todoList &#125;);</span><br><span class="line">  <span class="keyword">new</span> TodoView(&#123; el: $(<span class="string">'#todo-list'</span>) &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><code>View</code>中我们频繁使用到了<code>jQuery</code>的<code>find()</code>方法来查找<code>View</code>所在<code>el</code>下面的子元素，所以可以考虑将这作为<code>View</code>的特性来提供，于是我们为<code>View</code>定义这样一个名叫<code>$</code>方法，然后替换掉<code>this.el.find()</code>这样的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line">  <span class="keyword">this</span>.el = options.el;</span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.clearTextArea = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.$ = <span class="function"><span class="keyword">function</span><span class="params">(selector)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el = options.el;</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TodoView.prototype.appendTodo = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TodoView.prototype.$ = <span class="function"><span class="keyword">function</span><span class="params">(selector)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* … */</span></span><br></pre></td></tr></table></figure><br>上面的代码越来越多了，看上去好像咱是干的坏事，而不是往好的方向发展啊。是的，如果每个<code>View</code>都有很多自己的特性（方法），那向上面这样着实太痛苦了。看样子是时候请出<code>Backbone</code>提供的<code>View</code>特性了。OK，把我们自己的<code>View</code>转移到<code>Backbone</code>的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line">    <span class="keyword">this</span>.el = options.el;</span><br><span class="line"></span><br><span class="line">    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());</span><br><span class="line">  &#125;,</span><br><span class="line">  clearTextArea: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  $: <span class="function"><span class="keyword">function</span><span class="params">(selector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.el = options.el;</span><br><span class="line">    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  appendTodo: <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  $: <span class="function"><span class="keyword">function</span><span class="params">(selector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* … */</span></span><br></pre></td></tr></table></figure><br>由于<code>Backbone</code>的<code>View</code>已经提供了我们实现的<code>$()</code>方法的能力，也叫<code>$</code>（这也是之前我们自己命名的原因）；同时<code>Backbone</code>的<code>View</code>也提供了<code>this.el</code>的能力，所以可以把它们从代码中显示的移除了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());</span><br><span class="line">  &#125;,</span><br><span class="line">  clearTextArea: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  appendTodo: <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* 启动代码依然不变 */</span></span><br></pre></td></tr></table></figure><br>现在可以回过头来看看<code>ajax</code>那部分了，由于<code>Backbone</code>提供了<code>Model</code>的能力，这个就是用于和服务端打交道的，所以将长长的<code>ajax</code>代码改写为这一方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> Todo = Backbone.Model.extend(&#123;</span><br><span class="line">  url: <span class="string">'/add'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo();</span><br><span class="line">  todo.save(&#123; todoContent: todoContent &#125;,&#123;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(model, data)</span></span>&#123;</span><br><span class="line">      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* … */</span></span><br></pre></td></tr></table></figure><br>同时，<code>Backbone</code>中还提供了一个<code>Collection</code>的概念，也就是<code>Model</code>的集合，比如我们这个案例中，每次创建单条的<code>Todo</code>，然后形成<code>Todo List</code>。当然，我们的任何数据都应该是以多条记录的方式存在的。所以，我们同时将上面的<code>TodoList</code>的实现改为<code>Collection</code>。  </p>
<p>而且，<code>Backbone</code>的<code>Collection</code>已经支持了<code>Event</code>机制，所以我们也无需自定义<code>events</code>了，于是开头的<code>events</code>变量也一并移除了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = Backbone.Model.extend(&#123;</span><br><span class="line">  url: <span class="string">'/add'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoList = Backbone.Collection.extend(&#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo(),</span><br><span class="line">        that = <span class="keyword">this</span>;</span><br><span class="line">    todo.save(&#123; todoContent: todoContent &#125;,&#123;</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(model, data)</span></span>&#123;</span><br><span class="line">        that.trigger(<span class="string">'add'</span>, data.todoContent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());</span><br><span class="line">  &#125;,</span><br><span class="line">  clearTextArea: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line">    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  appendTodo: <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; el: $(<span class="string">'#new-todo'</span>), todoList: todoList &#125;);</span><br><span class="line">  <span class="keyword">new</span> TodoView(&#123; el: $(<span class="string">'#todo-list'</span>), todoList: todoList &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><code>Collection</code>提供了一个名叫<code>create()</code>的方法，其可以根据<code>Collection</code>的<code>Model</code>属性创建一个<code>Model</code>的实例，并执行<code>Model</code>的<code>save()</code>方法。所以我们的<code>TodoList</code>中的<code>add()</code>方法已经可以废去了。我们只需为<code>TodoList</code>提供<code>Model</code>属性的值即可，然后在<code>NewTodoView</code>的<code>addTodo()</code>方法中，替换<code>this.todoList.add()</code>方法为<code>this.todoList.create()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> TodoList = Backbone.Collection.extend(&#123;</span><br><span class="line">  model: Todo</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.todoList.create(&#123; todoContent: <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val() &#125;);  <span class="comment">//替换为create方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  clearTextArea: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* … */</span></span><br></pre></td></tr></table></figure><br>这时，我们的<code>Model</code>、<code>Collection</code>、<code>View</code>都已经齐上阵了。由于<code>Backbone</code>的<code>View</code>已经内置<code>collection</code>属性，使得我们可以设置、获取<code>View</code>对应的<code>Collection</code>，所以我们完全无需手动在<code>View</code>的内部来定义一个<code>todoList</code>的变量了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">var</span> NewTodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.collection.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.collection.create(&#123; todoContent: <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val() &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  clearTextArea: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoView = Backbone.View.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.collection.on(<span class="string">'add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  appendTodo: <span class="function"><span class="keyword">function</span><span class="params">(todo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.get(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; el: $(<span class="string">'#new-todo'</span>), collection: todoList &#125;);</span><br><span class="line">  <span class="keyword">new</span> TodoView(&#123; el: $(<span class="string">'#todo-list'</span>), collection: todoList &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>至此，完整的基于<code>Backbone</code>的<code>Model</code>、<code>Collection</code>、<code>View</code>模式就构建好了。如果说还有什么瑕疵的话，应该就是一些表层功夫了，那就是咱们的<code>HTML Element</code>的<code>append</code>了，需要做一些过滤，比如用户输入<code>JavaScript</code>代码那就糟糕了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.get(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">调整为</span><br><span class="line"><span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.escape(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><br>这样就Perfect了。文章忒长了点，但是为了从一个<code>0</code>变成一个<code>1</code>，我想应该还是很有意思的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继<a href="http://heroicyang.com/2012/08/08/to-backbone-tutorial-1">《Backbone之旅：前端MVC架构初体验（上）》</a>，上篇中最后的代码已经完全达到最初提出的几点要求，现在就结合<code>Backbone</code>提供的能力，来继续精简代码。最后的目标就是将上篇中的代码全部重构为<code>Backbone</code>的<code>MVC</code>模式。  </p>
<p>上篇中最后一次改造就已经使用到了<code>callback</code>的方式，所以我们索性再加上<code>Event</code>机制吧，因为<code>Backbone</code>内置了这个能力。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = _.clone(Backbone.Events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);</span><br><span class="line">  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add(&#123;</span><br><span class="line">    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后面不变*/</span></span><br></pre></td></tr></table></figure><br>现在既然调用<code>add()</code>时传入的<code>success</code>属性已经完全不涉及到<code>DOM</code>操作了，而是单纯的事件触发，那完全可以把这个行为放置到<code>TodoList</code>原型的<code>add()</code>方法中去了，这样重用性更高。  </p>]]>
    
    </summary>
    
      <category term="backbone" scheme="http://heroicyang.com/tags/backbone/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="mvc" scheme="http://heroicyang.com/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Backbone之旅：前端MVC架构初体验（上）]]></title>
    <link href="http://heroicyang.com/2012/08/08/to-backbone-tutorial-1/"/>
    <id>http://heroicyang.com/2012/08/08/to-backbone-tutorial-1/</id>
    <published>2012-08-07T16:48:00.000Z</published>
    <updated>2014-04-30T13:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>最近一段时间来，才算是真正的开始深入学习<code>JavaScript</code>，收获颇丰。也首次领略了前端<code>MVC</code>架构的风采，现在前端<code>MVC</code>的类库和框架越来越多，在经过初步的评估之后，决定先学习备受推崇的<code>Backbone</code>。 </p>
<p>以前自己做的一些<code>Web</code>应用，基本上都是按照非常传统的方式：1.服务器端渲染模板；2.利用<code>jQuery</code>的<code>ajax</code>进行异步数据交换。所以首次接触前端架构类的东西，难免有点无从下手。经过几天的奋战，以及参阅国外大牛们的各种<code>Tutorial</code>之后，终于拨开迷雾，缕了些头绪，自己也试着从传统的方式过渡（重构）出了所谓的架构性的代码。  </p>
<p>整个重构的过程让我受益良多，所以决定再认真的记录一遍，加深自己的印象，也再确认一遍自己是否真的搞明白了，文章应该会比较长。  </p>
<a id="more"></a>
<p>首先，先上一段所谓的传统式的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: <span class="string">'/add'</span>,</span><br><span class="line">      type: <span class="string">'POST'</span>,</span><br><span class="line">      dataType: <span class="string">'json'</span>,</span><br><span class="line">      data: &#123; todoContent: $(<span class="keyword">this</span>).find(<span class="string">'textarea'</span>).val() &#125;,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        $(that).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>另外，也上一张关于这篇文章中涉及到的<code>HTML</code>结构图，方便参照。由于文章稍长，我想如果直接在这里插图的话会影响阅读，所以就只给出<a href="http://img.heroicyang.com/to-backbone-tutorial.png" target="_blank" rel="external">图片链接</a>了。 </p>
<p>上面的一段代码我想应该都是大家非常熟悉的做法，因为我是一个伪前端攻城湿，所以我以前的代码中无不充斥着类似的、一堆一堆这样的代码。看上去貌似挺好的啊，也没啥问题，程序跑得倍儿棒。但是就这么短短的一段代码，它可干了不少事情：监听页面事件、用户事件、网络事件，接收用户的输入、执行网络的I/O、解析服务端返回的数据、动态生成<code>HTML</code>结构，可谓是包罗万象啊，就这么短短的一段代码就解释了整个<code>Web</code>应用程序的本质。  </p>
<p>所以即便是这么一个小小的应用，逻辑和架构上都已经臃肿了，完全违反了咱们软件开发中的“单一职责原则”。如果是一个大应用，那估计就如乱麻———剪不断理还乱了。所以，改变迫在眉睫。 </p>
<p>确实咱的要求也不高，如果把它搞成这样，其实咱就满足了：</p>
<ol>
<li>在<code>$(document).ready</code>当中只保留一些应用程序的初始化代码即可，即应用的启动程序。  </li>
<li>干掉乱如麻的逻辑，使得其符合咱们的“单一职责原则”，方便测试。  </li>
<li>减小<code>ajax</code>和<code>DOM</code>的耦合，其实也算是第2条。  </li>
</ol>
<p>OK，动手。按照最基本的重构方式，咱先把<code>ajax</code>分离到一个方法里面去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTodo = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val() &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">      $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    addTodo();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>但是，在<code>ajax</code>所在的方法中，<code>data</code>和<code>success</code>属性仍然保留了对<code>DOM</code>的依赖，于是接下来将其调整为函数的参数来传递。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTodo = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    addTodo(&#123;</span><br><span class="line">      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>好像OK了，不过此时<code>addTodo()</code>方法暴露在全局环境内，任何人都可以呼之欲来。我可不想当屌丝，作为一个富有上进心的、想成为一个合格前端攻城湿的我，还是给<code>addTodo()</code>方法加个命名空间吧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    todoList.add(&#123;</span><br><span class="line">      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>现在<code>submit</code>事件只依赖一个<code>todoList</code>变量了，而且最重要的是现在的<code>submit</code>事件中只关注<code>DOM</code>操作了，干脆大刀阔斧的把它移到外层去。于是咱们引入视图<code>View</code>了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    todoList.add(&#123;</span><br><span class="line">      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; todoList: todoList &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>恩，现如今<code>$(document).ready</code>中就简洁得只剩我们之前所说的应用启动代码了。虽然代码已经组件化了，也工作得很好，但是仍然有需要重构的地方。<code>NewTodoView</code>目前看上去都不怎么像一个对象的行为，所以继续重构之。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoList = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">TodoList.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/add'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123; todoContent: options.todoContent &#125;,</span><br><span class="line">    success: options.success</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewTodoView = <span class="function"><span class="keyword">function</span><span class="params">(options)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = options.todoList;</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">this</span>.todoList.add(&#123;</span><br><span class="line">    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">      $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();</span><br><span class="line">  <span class="keyword">new</span> NewTodoView(&#123; todoList: todoList &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里用到了<code>jQuery</code>中的<code>$.proxy()</code>方法来解决<code>this</code>作用域的问题，玩<code>JavaScript</code>的童鞋们应该都很了解作用域这个东东。接下来，咱干点有关洁癖的事情，鉴于要保证代码的清晰、方便阅读，咱把<code>success</code>里面的行为采用<code>callback</code>的形式来完成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*前面不变*/</span></span><br><span class="line">NewTodoView.prototype.addTodo = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.todoList.add(&#123;</span><br><span class="line">    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      that.appendTodo(data.todoContent);</span><br><span class="line">      that.clearTextArea();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.appendTodo = <span class="function"><span class="keyword">function</span><span class="params">(todoContent)</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewTodoView.prototype.clearTextArea = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*后面也不变*/</span></span><br></pre></td></tr></table></figure><br>至此，重构的第一个版本其实就算得上大功告成了，已经达到前面提出的三大方针政策。文章果然比较长，所以我决定还是分成了上、下两节，当前这篇中完全没涉及到<code>backbone</code>，所以到此就打住了，敬请关注下回分解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一段时间来，才算是真正的开始深入学习<code>JavaScript</code>，收获颇丰。也首次领略了前端<code>MVC</code>架构的风采，现在前端<code>MVC</code>的类库和框架越来越多，在经过初步的评估之后，决定先学习备受推崇的<code>Backbone</code>。 </p>
<p>以前自己做的一些<code>Web</code>应用，基本上都是按照非常传统的方式：1.服务器端渲染模板；2.利用<code>jQuery</code>的<code>ajax</code>进行异步数据交换。所以首次接触前端架构类的东西，难免有点无从下手。经过几天的奋战，以及参阅国外大牛们的各种<code>Tutorial</code>之后，终于拨开迷雾，缕了些头绪，自己也试着从传统的方式过渡（重构）出了所谓的架构性的代码。  </p>
<p>整个重构的过程让我受益良多，所以决定再认真的记录一遍，加深自己的印象，也再确认一遍自己是否真的搞明白了，文章应该会比较长。  </p>]]>
    
    </summary>
    
      <category term="backbone" scheme="http://heroicyang.com/tags/backbone/"/>
    
      <category term="javascript" scheme="http://heroicyang.com/tags/javascript/"/>
    
      <category term="mvc" scheme="http://heroicyang.com/tags/mvc/"/>
    
  </entry>
  
</feed>